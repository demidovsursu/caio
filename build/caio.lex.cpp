// build/caio.lex.cpp generated by reflex 2.1.5 from build/caio.lex

#define REFLEX_VERSION "2.1.5"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_bison_bridge        true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "build/caio.lex.cpp"
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "caio.hpp"
#define YY_USER_ACTION yysetloc();


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define S_CODE (1)
#define S_GRM (2)
#define S_LEX (3)
#define S_LEX2 (4)
#define S_LIST (5)
#define S_NODE (6)
#define S_RE (7)
#define S_RE2 (8)
#define S_STATE (9)
#define S_TERM (10)
#define S_TOKEN (11)
#define YY_NUM_RULES (127)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {

public:
  std::vector<std::string> filenames;
  int activefile;


public: YYLTYPE yylloc;
  void yysetloc(){
    yylloc.first.line=lineno();
    yylloc.first.file=activefile;
    yylloc.first.column=short(columno()+1);
    yylloc.last.line=lineno();
    yylloc.last.file=activefile;
    yylloc.last.column=short(columno()+size());
  }

 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {

  filenames.push_back("");
  activefile=0;

  }
  virtual int yylex(void)
  {
    LexerError("yyFlexLexer::yylex invoked but %option bison-bridge and/or bison-locations is used");
    yyterminate();
  }
  virtual int yylex(YYSTYPE& yylval);
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


int caio_mode=M_DECL;
string re_str,code_dest;
static string reinput(yyFlexLexer& scanner, int nl)
{ string re="R\"";
  int k=0;
  int r=0,c;
  bool err=0;
  while((c=scanner.input())!=0)
  { re+=char(c);
    if(c=='\n' && !nl) break;
    if(c=='(') break;
    ++k;
    if(r==0) r=c;
    else if(r!=c) break;
  }
  if(c=='(')
  {
    int kk=-1;
    while((c=scanner.input())!=0)
    { re+=char(c);
      if(c=='\n' && !nl) break;
      if(c==')') kk=k;
      else if(kk==0 && c=='"') break;
      else if(kk>0 && c==r) --kk;
      else kk=-1;
    }
    if(c!='"' || re.size()<=5+2*k) err=1;
  }
  else err=1;
  if(err)
  { yyerror(&(scanner.yylloc),&scanner,"RE error");
  }
  return re;
}


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef void *yyscan_t;
typedef yyFlexLexer yyscanner_t;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

YY_EXTERN_C int yylex(YYSTYPE *lvalp, yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->yylex(*lvalp);
}

YY_EXTERN_C void yylex_init(yyscan_t *scanner)
{
  *scanner = static_cast<yyscan_t>(new yyscanner_t);
}

YY_EXTERN_C void yylex_init_extra(void* extra, yyscan_t *scanner)
{
  *scanner = static_cast<yyscan_t>(new yyscanner_t);
  yyset_extra(extra, *scanner);
}

YY_EXTERN_C void yylex_destroy(yyscan_t scanner)
{
  delete static_cast<yyscanner_t*>(scanner);
}

#undef yyget_text
YY_EXTERN_C char *yyget_text(yyscan_t scanner)
{
  return const_cast<char*>(static_cast<yyscanner_t*>(scanner)->text());
}

#undef yyget_leng
YY_EXTERN_C yy_size_t yyget_leng(yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->size();
}

#undef yyget_lineno
YY_EXTERN_C int yyget_lineno(yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->lineno();
}

#undef yyset_lineno
YY_EXTERN_C void yyset_lineno(int n, yyscan_t scanner)
{
  static_cast<yyscanner_t*>(scanner)->lineno(n);
}

#undef yyget_in
YY_EXTERN_C FILE *yyget_in(yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->in().file();
}

#undef yyset_in
YY_EXTERN_C void yyset_in(FILE *i, yyscan_t scanner)
{
  static_cast<yyscanner_t*>(scanner)->in(i);
}

#undef yyget_debug
YY_EXTERN_C int yyget_debug(yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->debug();
}

#undef yyset_debug
YY_EXTERN_C void yyset_debug(int f, yyscan_t scanner)
{
  static_cast<yyscanner_t*>(scanner)->set_debug(f);
}

#undef yyget_extra
YY_EXTERN_C void* yyget_extra(yyscan_t scanner)
{
  return static_cast<yyscanner_t*>(scanner)->yyextra;
}

#undef yyset_extra
YY_EXTERN_C void yyset_extra(void* x, yyscan_t scanner)
{
  static_cast<yyscanner_t*>(scanner)->yyextra = x;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int yyFlexLexer::yylex(YYSTYPE& yylval)
{
  static const char *REGEX_INITIAL = "(?m)(^(?:\\Q%type\\E))|(^(?:\\Q%code\\E))|(^(?:\\Q%option\\E))|(^(?:\\Q%using\\E))|(^(?:\\Q%operator\\E))|(^(?:[A-Z_a-z][0-9A-Z_a-z]*))|(\\d+)|((?:\\Q%{\\E)|(?:\\Q{\\E))|((?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][\\x2d.0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*))|((?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))|([\\x09\\x20])|(^(?:\\Q%%\\E).*\\n)|((?:\\Q//\\E).*\\n)|((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|(.|\\n)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_S_CODE = "(?m)((?:'(?:[^\\x0a'\\x5c]|\\\\(?:x[0-9A-Fa-f]+|[0-9]+|.))'))|((?:\"(?:[^\\x0a\"\\x5c]|\\\\.)*\"))|(R\")|(default)|((?:\\Q:\\E))|(match)|(visitor)|(return(?=[\\x09\\x0a\\x0d\\x20]*[\"'\\x3f]))|(token[\\x09\\x0a\\x0d\\x20]*(?=[\"'\\x3f]))|(rule)|(visit)|((?:[A-Z_a-z][0-9A-Z_a-z]*))|((?:\\d+['0-9A-Za-z]*|\\d['0-9]*(?:\\.['0-9]*)?(?:[Ee][\\x2b\\x2d]?\\d+[0-9A-Za-z]*)?))|((?:\\Q$$\\E)|(?:\\Q@$\\E))|((?:\\Q$\\E)[0-9]+|(?:\\Q$\\E)\\[(?:(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][\\x2d.0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*)|(?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))\\]|(?:\\Q$\\E)(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*))|((?:\\Q{\\E))|((?:\\Q}\\E))|((?:\\Q%}\\E))|([\\x09\\x0a\\x20]+)|((?:\\Q/*\\E).*?(?:\\Q*/\\E))|((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|((?:\\Q//\\E).*\\n)|(.)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_CODE(REGEX_S_CODE);
  static const char *REGEX_S_GRM = "(?m)((?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][\\x2d.0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*))|((?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))|((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|([\\x09\\x0a\\x0d\\x20])|((?:\\Q//\\E).*\\n)|(^(?:\\Q%%\\E).*\\n)|((?:\\Q{\\E))|((?:\\Q%{\\E))|(!)|((?:\\Q.\\E))|((?:\\Q(/\\E))|((?:\\Q/)\\E))|((?:\\Q(:\\E))|((?:\\Q:)\\E))|((?:\\Q/\\E))|((?:\\Q<\\E))|(.|\\n)";
  static const reflex::Pattern PATTERN_S_GRM(REGEX_S_GRM);
  static const char *REGEX_S_LEX = "(?m)(^(?:\\Q%%\\E).*\\n)|(^(?:\\Q<\\E)(?=[^<]))|(^(?:\\Q%{\\E)(?=[\\x09\\x0a\\x20]))|(R\")|([\\x09\\x20])|([\\x09\\x20]*\\n)|(.)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_LEX(REGEX_S_LEX);
  static const char *REGEX_S_LEX2 = "(?m)((?:\\Q%{\\E)|(?:\\Q{\\E))|((?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))|((?:\\Q//\\E).*\\n)|((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|((?:\\Q<\\E))|([\\x09\\x20])|(\\n)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_LEX2(REGEX_S_LEX2);
  static const char *REGEX_S_LIST = "(?m)((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|((?:'(?:[^\\x0a'\\x5c]|\\\\(?:x[0-9A-Fa-f]+|[0-9]+|.))'))|((?:\"(?:[^\\x0a\"\\x5c]|\\\\.)*\"))|(R\")|((?:[A-Z_a-z][0-9A-Z_a-z]*))|((?:\\d+['0-9A-Za-z]*|\\d['0-9]*(?:\\.['0-9]*)?(?:[Ee][\\x2b\\x2d]?\\d+[0-9A-Za-z]*)?))|((?:\\Q$$\\E)|(?:\\Q@$\\E))|((?:\\Q$\\E)[0-9]+|(?:\\Q$\\E)\\[(?:(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][\\x2d.0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*)|(?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))\\]|(?:\\Q$\\E)(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*))|((?:\\Q//\\E).*\\n)|((?:\\Q{\\E))|((?:\\Q)\\E))|((?:\\Q(\\E))|([\\x09\\x0a\\x20]+)|((?:\\Q,\\E))|(.)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_LIST(REGEX_S_LIST);
  static const char *REGEX_S_NODE = "(?m)((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|((?:\\Q//\\E).*\\n)|((?:\\Q:\\E))|((?:\\Q{\\E))|((?:[A-Z_a-z][0-9A-Z_a-z]*))|([\\x09\\x0a\\x20])|(.|\\n)";
  static const reflex::Pattern PATTERN_S_NODE(REGEX_S_NODE);
  static const char *REGEX_S_RE = "(?m)(\\\\.)|(\"(?:[^\\x0a\"\\x5c]|\\\\.)*\")|(\\[(?:[^\\x0a\\x5c\\x5d]|\\\\.)*\\])|([\\x09\\x20])|(.)|(\\n)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_RE(REGEX_S_RE);
  static const char *REGEX_S_RE2 = "(?m)([\\x09\\x20])|(\\n)|(R\")|(.)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_RE2(REGEX_S_RE2);
  static const char *REGEX_S_STATE = "(?m)(\\n)|((?:[A-Z_a-z][0-9A-Z_a-z]*))|([\\x09\\x20])|((?:\\Q>\\E))|(.|\\n)";
  static const reflex::Pattern PATTERN_S_STATE(REGEX_S_STATE);
  static const char *REGEX_S_TERM = "(?m)((?:\\Q/*\\E)(?:.|\\n)*?(?:\\Q*/\\E))|([\\x09\\x0a\\x0d\\x20])|((?:\\Q>\\E))|((?:\\Q(\\E))|((?:'(?:[^\\x0a'\\x5c]|\\\\(?:x[0-9A-Fa-f]+|[0-9]+|.))'))|((?:\"(?:[^\\x0a\"\\x5c]|\\\\.)*\"))|(R\")|((?:[A-Z_a-z][0-9A-Z_a-z]*))|((?:\\d+['0-9A-Za-z]*|\\d['0-9]*(?:\\.['0-9]*)?(?:[Ee][\\x2b\\x2d]?\\d+[0-9A-Za-z]*)?))|((?:\\Q$\\E)[0-9]+|(?:\\Q$\\E)\\[(?:(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][\\x2d.0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*)|(?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))\\]|(?:\\Q$\\E)(?:[A-Za-z\\xa8\\xb8\\xc0-\\xff][0-9A-Z_a-z\\xa8\\xb8\\xc0-\\xff]*))|(.|\\n)";
  static const reflex::Pattern PATTERN_S_TERM(REGEX_S_TERM);
  static const char *REGEX_S_TOKEN = "(?m)((?:'(?:[^\\x09\\x0a'\\x5c]|\\\\[^\\x09\\x0a])+')|(?:\"(?:[^\\x09\\x0a\"\\x5c]|\\\\[^\\x09\\x0a])+\")|(?:\\?[^\\x09\\x0a\\x20\\x3f]+\\?))|([\\x09\\x0a\\x20]+)|(.)|(.|\\n)";
  static const reflex::Pattern PATTERN_S_TOKEN(REGEX_S_TOKEN);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:78: ^"%type" :
            YY_USER_ACTION
{ return 1004; }
            YY_BREAK
          case 2: // rule build/caio.lex:79: ^"%code" :
            YY_USER_ACTION
{ return 1001; }
            YY_BREAK
          case 3: // rule build/caio.lex:80: ^"%option" :
            YY_USER_ACTION
{ return 1003; }
            YY_BREAK
          case 4: // rule build/caio.lex:81: ^"%using" :
            YY_USER_ACTION
{ return 1005; }
            YY_BREAK
          case 5: // rule build/caio.lex:82: ^"%operator" :
            YY_USER_ACTION
{ return 1002; }
            YY_BREAK
          case 6: // rule build/caio.lex:83: ^{ident} :
            YY_USER_ACTION
{
	#line 119 "caio.caio"
                            yylval.f1_=yytext; BEGIN(S_RE2); return (1016); 	}
            YY_BREAK
          case 7: // rule build/caio.lex:86: \d+ :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1018; }
            YY_BREAK
          case 8: // rule build/caio.lex:87: "%{"|"{" :
            YY_USER_ACTION
{
	#line 121 "caio.caio"
                                     yy_push_state(S_CODE);  return (1006); 	}
            YY_BREAK
          case 9: // rule build/caio.lex:90: {symbol} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 10: // rule build/caio.lex:91: {cliteral}|{sliteral}|{qliteral} :
            YY_USER_ACTION
{
	#line 123 "caio.caio"

            yylval.f1_=yytext; if(YYSTATE==S_TOKEN) yy_pop_state(); return (1022); 	}
            YY_BREAK
          case 11: // rule build/caio.lex:95: [ \t] :
            YY_USER_ACTION
;
            YY_BREAK
          case 12: // rule build/caio.lex:96: ^"%%".*\n :
            YY_USER_ACTION
{
	#line 126 "caio.caio"
            if(yylex_flag) { BEGIN(S_LEX); caio_mode=M_LEX; return (1014); }
            if(yyparse_flag) { BEGIN(S_GRM); caio_mode=M_GRM; return (1013); }
            BEGIN(S_CODE); caio_mode=M_CODE; return (1012);
          	}
            YY_BREAK
          case 13: // rule build/caio.lex:102: "//".*\n :
            YY_USER_ACTION
{ return '\n'; }
            YY_BREAK
          case 14: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 15: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_CODE:
        matcher().pattern(PATTERN_S_CODE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:175: {char_const} :
            YY_USER_ACTION
{
	#line 168 "caio.caio"
                                     yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 2: // rule build/caio.lex:178: {string_const} :
            YY_USER_ACTION
{
	#line 169 "caio.caio"
                                       yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 3: // rule build/caio.lex:181: R\" :
            YY_USER_ACTION
{
	#line 170 "caio.caio"
                                 yylval.f1_=reinput(YY_SCANNER,1); return (1015); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:184: default :
            YY_USER_ACTION
{ return 1007; }
            YY_BREAK
          case 5: // rule build/caio.lex:185: ":" :
            YY_USER_ACTION
{ return ':'; }
            YY_BREAK
          case 6: // rule build/caio.lex:186: match :
            YY_USER_ACTION
{
	#line 173 "caio.caio"
                yy_push_state(S_LIST); return (1008); 	}
            YY_BREAK
          case 7: // rule build/caio.lex:189: visitor :
            YY_USER_ACTION
{
	#line 174 "caio.caio"
                  yy_push_state(S_NODE); return (1011); 	}
            YY_BREAK
          case 8: // rule build/caio.lex:192: return/[\ \t\n\r]*['\"?] :
            YY_USER_ACTION
{
	#line 175 "caio.caio"
                                       if(caio_mode==M_LEX) yy_push_state(S_TOKEN); yylval.f1_=yytext; return (1016); 	}
            YY_BREAK
          case 9: // rule build/caio.lex:195: token[\ \t\n\r]*/['\"?] :
            YY_USER_ACTION
{
	#line 176 "caio.caio"
                                      yy_push_state(S_TOKEN); 	}
            YY_BREAK
          case 10: // rule build/caio.lex:198: rule :
            YY_USER_ACTION
{
	#line 177 "caio.caio"
               yy_push_state(S_NODE); return (1009); 	}
            YY_BREAK
          case 11: // rule build/caio.lex:201: visit :
            YY_USER_ACTION
{
	#line 178 "caio.caio"
                yy_push_state(S_NODE); return (1010); 	}
            YY_BREAK
          case 12: // rule build/caio.lex:204: {ident} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 13: // rule build/caio.lex:205: {number} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1015; }
            YY_BREAK
          case 14: // rule build/caio.lex:206: "$$"|"@$" :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1020; }
            YY_BREAK
          case 15: // rule build/caio.lex:207: "$"[0-9]+|"$"\[({symbol}|{cliteral}|{sliteral}|{qliteral})\]|"$"{symbolid} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1020; }
            YY_BREAK
          case 16: // rule build/caio.lex:246: "{" :
            YY_USER_ACTION
{
	#line 207 "caio.caio"
              yy_push_state(S_CODE); return ('{'); 	}
            YY_BREAK
          case 17: // rule build/caio.lex:249: "}" :
            YY_USER_ACTION
{
	#line 208 "caio.caio"
              if(state_.size()>0) yy_pop_state(); return ('}'); 	}
            YY_BREAK
          case 18: // rule build/caio.lex:252: "%}" :
            YY_USER_ACTION
{
	#line 209 "caio.caio"
               if(state_.size()>0 && yy_top_state()!=S_CODE) { yy_pop_state(); return ('}');} yyunput('}'); yylval.f1_="%"s; return (1017); 	}
            YY_BREAK
          case 19: // rule build/caio.lex:255: [ \t\n]+ :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1021; }
            YY_BREAK
          case 20: // rule build/caio.lex:256: "/*".*?"*/" :
            YY_USER_ACTION
{
	#line 211 "caio.caio"
                      yylval.f1_=" "; return (1021); 	}
            YY_BREAK
          case 21: // rule build/caio.lex:259: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
{
	#line 212 "caio.caio"
                           yylval.f1_="\n"; return (1021); 	}
            YY_BREAK
          case 22: // rule build/caio.lex:262: "//".*\n :
            YY_USER_ACTION
{
	#line 213 "caio.caio"
                   yylval.f1_="\n"; return (1021); 	}
            YY_BREAK
          case 23: // rule build/caio.lex:266: . :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1017; }
            YY_BREAK
          case 24: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_GRM:
        matcher().pattern(PATTERN_S_GRM);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:90: {symbol} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 2: // rule build/caio.lex:91: {cliteral}|{sliteral}|{qliteral} :
            YY_USER_ACTION
{
	#line 123 "caio.caio"

            yylval.f1_=yytext; if(YYSTATE==S_TOKEN) yy_pop_state(); return (1022); 	}
            YY_BREAK
          case 3: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 4: // rule build/caio.lex:168: [ \t\r\n] :
            YY_USER_ACTION
;
            YY_BREAK
          case 5: // rule build/caio.lex:208: "//".*\n :
            YY_USER_ACTION
;
            YY_BREAK
          case 6: // rule build/caio.lex:209: ^"%%".*\n :
            YY_USER_ACTION
{
	#line 185 "caio.caio"
                   BEGIN(S_CODE); caio_mode=M_CODE; return (1012); 	}
            YY_BREAK
          case 7: // rule build/caio.lex:212: "{" :
            YY_USER_ACTION
{
	#line 186 "caio.caio"
             if(bnf_flag!=1) { yy_push_state(S_CODE); return (1006); }  return ('{'); 	}
            YY_BREAK
          case 8: // rule build/caio.lex:215: "%{" :
            YY_USER_ACTION
{
	#line 187 "caio.caio"
              yy_push_state(S_CODE); return (1006); 	}
            YY_BREAK
          case 9: // rule build/caio.lex:218: ! :
            YY_USER_ACTION
{ return '|'; }
            YY_BREAK
          case 10: // rule build/caio.lex:219: "." :
            YY_USER_ACTION
{ return ';'; }
            YY_BREAK
          case 11: // rule build/caio.lex:220: "(/" :
            YY_USER_ACTION
{ return '['; }
            YY_BREAK
          case 12: // rule build/caio.lex:221: "/)" :
            YY_USER_ACTION
{ return ']'; }
            YY_BREAK
          case 13: // rule build/caio.lex:222: "(:" :
            YY_USER_ACTION
{ return '{'; }
            YY_BREAK
          case 14: // rule build/caio.lex:223: ":)" :
            YY_USER_ACTION
{ return '}'; }
            YY_BREAK
          case 15: // rule build/caio.lex:224: "/" :
            YY_USER_ACTION
{ return '|'; }
            YY_BREAK
          case 16: // rule build/caio.lex:225: "<" :
            YY_USER_ACTION
{
	#line 195 "caio.caio"
             yy_push_state(S_TERM); return ('<'); 	}
            YY_BREAK
          case 17: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_LEX:
        matcher().pattern(PATTERN_S_LEX);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:133: ^"%%".*\n :
            YY_USER_ACTION
{
	#line 146 "caio.caio"
                   if(yyparse_flag) { BEGIN(S_GRM); caio_mode=M_GRM; return (1013); }
                   BEGIN(S_CODE); caio_mode=M_CODE; return (1012);
            	}
            YY_BREAK
          case 2: // rule build/caio.lex:138: ^"<"/[^<] :
            YY_USER_ACTION
{
	#line 149 "caio.caio"
                   BEGIN(S_STATE); return ('<'); 	}
            YY_BREAK
          case 3: // rule build/caio.lex:141: ^"%{"/[ \t\n] :
            YY_USER_ACTION
{
	#line 150 "caio.caio"
                       yy_push_state(S_CODE);  return (1006); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:147: R\" :
            YY_USER_ACTION
{
	#line 152 "caio.caio"
                  yylval.f1_=reinput(YY_SCANNER,0); BEGIN(S_LEX2);
             return (1019);
           	}
            YY_BREAK
          case 5: // rule build/caio.lex:152: [ \t] :
            YY_USER_ACTION
{
	#line 155 "caio.caio"
               BEGIN(S_LEX2); 	}
            YY_BREAK
          case 6: // rule build/caio.lex:155: [ \t]*\n :
            YY_USER_ACTION
{ return '\n'; }
            YY_BREAK
          case 7: // rule build/caio.lex:156: . :
            YY_USER_ACTION
{
	#line 157 "caio.caio"
           re_str=""; yyunput(yytext[0]); BEGIN(S_LEX2); yy_push_state(S_RE); 	}
            YY_BREAK
          case 8: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_LEX2:
        matcher().pattern(PATTERN_S_LEX2);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:87: "%{"|"{" :
            YY_USER_ACTION
{
	#line 121 "caio.caio"
                                     yy_push_state(S_CODE);  return (1006); 	}
            YY_BREAK
          case 2: // rule build/caio.lex:91: {cliteral}|{sliteral}|{qliteral} :
            YY_USER_ACTION
{
	#line 123 "caio.caio"

            yylval.f1_=yytext; if(YYSTATE==S_TOKEN) yy_pop_state(); return (1022); 	}
            YY_BREAK
          case 3: // rule build/caio.lex:103: "//".*\n :
            YY_USER_ACTION
{
	#line 131 "caio.caio"
                   BEGIN(S_LEX); return ('\n'); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 5: // rule build/caio.lex:144: "<" :
            YY_USER_ACTION
{
	#line 151 "caio.caio"
              yy_push_state(S_TERM); return ('<'); 	}
            YY_BREAK
          case 6: // rule build/caio.lex:159: [ \t] :
            YY_USER_ACTION
;
            YY_BREAK
          case 7: // rule build/caio.lex:160: \n :
            YY_USER_ACTION
{
	#line 159 "caio.caio"
                     BEGIN(S_LEX); return ('\n'); 	}
            YY_BREAK
          case 8: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_LIST:
        matcher().pattern(PATTERN_S_LIST);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 2: // rule build/caio.lex:175: {char_const} :
            YY_USER_ACTION
{
	#line 168 "caio.caio"
                                     yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 3: // rule build/caio.lex:178: {string_const} :
            YY_USER_ACTION
{
	#line 169 "caio.caio"
                                       yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:181: R\" :
            YY_USER_ACTION
{
	#line 170 "caio.caio"
                                 yylval.f1_=reinput(YY_SCANNER,1); return (1015); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:204: {ident} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 6: // rule build/caio.lex:205: {number} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1015; }
            YY_BREAK
          case 7: // rule build/caio.lex:206: "$$"|"@$" :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1020; }
            YY_BREAK
          case 8: // rule build/caio.lex:207: "$"[0-9]+|"$"\[({symbol}|{cliteral}|{sliteral}|{qliteral})\]|"$"{symbolid} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1020; }
            YY_BREAK
          case 9: // rule build/caio.lex:208: "//".*\n :
            YY_USER_ACTION
;
            YY_BREAK
          case 10: // rule build/caio.lex:228: "{" :
            YY_USER_ACTION
{
	#line 197 "caio.caio"
              BEGIN(S_CODE); return ('{'); 	}
            YY_BREAK
          case 11: // rule build/caio.lex:231: ")" :
            YY_USER_ACTION
{
	#line 198 "caio.caio"
              yy_pop_state(); return (')'); 	}
            YY_BREAK
          case 12: // rule build/caio.lex:234: "(" :
            YY_USER_ACTION
{
	#line 199 "caio.caio"
              yy_push_state(S_LIST); return ('('); 	}
            YY_BREAK
          case 13: // rule build/caio.lex:237: [ \t\n]+ :
            YY_USER_ACTION
;
            YY_BREAK
          case 14: // rule build/caio.lex:265: "," :
            YY_USER_ACTION
{ return ','; }
            YY_BREAK
          case 15: // rule build/caio.lex:266: . :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1017; }
            YY_BREAK
          case 16: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_NODE:
        matcher().pattern(PATTERN_S_NODE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 2: // rule build/caio.lex:208: "//".*\n :
            YY_USER_ACTION
;
            YY_BREAK
          case 3: // rule build/caio.lex:238: ":" :
            YY_USER_ACTION
{
	#line 202 "caio.caio"
              yy_pop_state(); return (':'); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:241: "{" :
            YY_USER_ACTION
{
	#line 203 "caio.caio"
              BEGIN(S_CODE); return ('{'); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:244: {ident} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 6: // rule build/caio.lex:245: [ \t\n] :
            YY_USER_ACTION
;
            YY_BREAK
          case 7: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_RE:
        matcher().pattern(PATTERN_S_RE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:115: \\. :
            YY_USER_ACTION
{
	#line 139 "caio.caio"
            re_str+=yytext; 	}
            YY_BREAK
          case 2: // rule build/caio.lex:118: \"([^\"\\\n]|\\.)*\" :
            YY_USER_ACTION
{
	#line 140 "caio.caio"
                                  re_str+=yytext; 	}
            YY_BREAK
          case 3: // rule build/caio.lex:121: \[([^\]\\\n]|\\.)*\] :
            YY_USER_ACTION
{
	#line 141 "caio.caio"
                                  re_str+=yytext; 	}
            YY_BREAK
          case 4: // rule build/caio.lex:124: [ \t] :
            YY_USER_ACTION
{
	#line 142 "caio.caio"
              yylval.f1_=re_str; yy_pop_state(); return (1019); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:127: . :
            YY_USER_ACTION
{
	#line 143 "caio.caio"
          re_str+=yytext; 	}
            YY_BREAK
          case 6: // rule build/caio.lex:130: \n :
            YY_USER_ACTION
{
	#line 144 "caio.caio"
           yylval.f1_=re_str; yy_pop_state(); yyunput('\n'); return (1019); 	}
            YY_BREAK
          case 7: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_RE2:
        matcher().pattern(PATTERN_S_RE2);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:107: [ \t] :
            YY_USER_ACTION
;
            YY_BREAK
          case 2: // rule build/caio.lex:108: \n :
            YY_USER_ACTION
{ return '\n'; }
            YY_BREAK
          case 3: // rule build/caio.lex:109: R\" :
            YY_USER_ACTION
{
	#line 136 "caio.caio"
                  yylval.f1_=reinput(YY_SCANNER,0); BEGIN(INITIAL);  return (1019); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:112: . :
            YY_USER_ACTION
{
	#line 137 "caio.caio"
           re_str=""; yyunput(yytext[0]); BEGIN(INITIAL); yy_push_state(S_RE); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_STATE:
        matcher().pattern(PATTERN_S_STATE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:160: \n :
            YY_USER_ACTION
{
	#line 159 "caio.caio"
                     BEGIN(S_LEX); return ('\n'); 	}
            YY_BREAK
          case 2: // rule build/caio.lex:163: {ident} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 3: // rule build/caio.lex:164: [ \t] :
            YY_USER_ACTION
;
            YY_BREAK
          case 4: // rule build/caio.lex:165: ">" :
            YY_USER_ACTION
{
	#line 163 "caio.caio"
               BEGIN(S_LEX); return ('>'); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_TERM:
        matcher().pattern(PATTERN_S_TERM);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:106: "/*"(.|\n)*?"*/" :
            YY_USER_ACTION
;
            YY_BREAK
          case 2: // rule build/caio.lex:168: [ \t\r\n] :
            YY_USER_ACTION
;
            YY_BREAK
          case 3: // rule build/caio.lex:169: ">" :
            YY_USER_ACTION
{
	#line 166 "caio.caio"
              yy_pop_state(); return ('>'); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:172: "(" :
            YY_USER_ACTION
{
	#line 167 "caio.caio"
              yy_push_state(S_LIST); return ('('); 	}
            YY_BREAK
          case 5: // rule build/caio.lex:175: {char_const} :
            YY_USER_ACTION
{
	#line 168 "caio.caio"
                                     yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 6: // rule build/caio.lex:178: {string_const} :
            YY_USER_ACTION
{
	#line 169 "caio.caio"
                                       yylval.f1_=yytext; return (1015); 	}
            YY_BREAK
          case 7: // rule build/caio.lex:181: R\" :
            YY_USER_ACTION
{
	#line 170 "caio.caio"
                                 yylval.f1_=reinput(YY_SCANNER,1); return (1015); 	}
            YY_BREAK
          case 8: // rule build/caio.lex:204: {ident} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1016; }
            YY_BREAK
          case 9: // rule build/caio.lex:205: {number} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1015; }
            YY_BREAK
          case 10: // rule build/caio.lex:207: "$"[0-9]+|"$"\[({symbol}|{cliteral}|{sliteral}|{qliteral})\]|"$"{symbolid} :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1020; }
            YY_BREAK
          case 11: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      case S_TOKEN:
        matcher().pattern(PATTERN_S_TOKEN);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule build/caio.lex:91: {cliteral}|{sliteral}|{qliteral} :
            YY_USER_ACTION
{
	#line 123 "caio.caio"

            yylval.f1_=yytext; if(YYSTATE==S_TOKEN) yy_pop_state(); return (1022); 	}
            YY_BREAK
          case 2: // rule build/caio.lex:255: [ \t\n]+ :
            YY_USER_ACTION
{ yylval.f1_=yytext;  return 1021; }
            YY_BREAK
          case 3: // rule build/caio.lex:267: . :
            YY_USER_ACTION
{
	#line 216 "caio.caio"
             yy_pop_state(); yylval.f1_=yytext; return (1017); 	}
            YY_BREAK
          case 4: // rule build/caio.lex:270: .|\n :
            YY_USER_ACTION
return yyliteral(yytext);
            YY_BREAK
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


int yylex(YYSTYPE* lvalp, YYLTYPE* llocp, void* scanner) {
  yyscanner_t* scanp=static_cast<yyscanner_t*>(scanner);
  yyclear_attr(*lvalp);
  int t=scanp->yylex(*lvalp);
  *llocp=scanp->yylloc;
  return t;
}

const char *yylex_filename(void* scanner, int i)
{ yyscanner_t* scanp=static_cast<yyscanner_t*>(scanner);
  if(i>=scanp->filenames.size()) return "";
  if(i<0) i=scanp->activefile;
  return scanp->filenames[i].c_str();
}
void yylex_init(yyscan_t *scanner, FILE *f, const std::string& n)
{ yyscanner_t* scanp=new yyscanner_t;
  *scanner = static_cast<yyscan_t>(scanp);
  scanp->in(reflex::Input(f));
  scanp->filenames[0]=n;
}
void yylex_init(yyscan_t *scanner, const std::string& s)
{ yyscanner_t* scanp=new yyscanner_t;
  *scanner = static_cast<yyscan_t>(scanp);
  scanp->in(s);
}
void yylex_init(yyscan_t *scanner, std::istream &s, const std::string& n)
{ yyscanner_t* scanp=new yyscanner_t;
  *scanner = static_cast<yyscan_t>(scanp);
  scanp->in(reflex::Input(s));
  scanp->filenames[0]=n;
}
