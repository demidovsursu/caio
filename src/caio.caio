%option noyywrap noliteral-rules nomatcherror locations lexprint astprint
%{
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <regex>
#include <vector>
#include <utility>
#include <algorithm>
#include <cctype>
using namespace std;
enum Caio_mode { M_DECL, M_LEX, M_GRM, M_CODE };
extern int caio_mode;
%}
%code lex {
%{
int caio_mode=M_DECL;
string re_str,code_dest;
static string reinput(yyFlexLexer& scanner, int nl)
{ string re="R\"";
  int k=0; 
  int r=0,c;
  bool err=0;
  while((c=scanner.input())!=0)
  { re+=char(c);
    if(c=='\n' && !nl) break;
    if(c=='(') break;
    ++k;
    if(r==0) r=c;
    else if(r!=c) break;
  }
  if(c=='(') 
  {
    int kk=-1;
    while((c=scanner.input())!=0)
    { re+=char(c);
      if(c=='\n' && !nl) break;
      if(c==')') kk=k;
      else if(kk==0 && c=='"') break;
      else if(kk>0 && c==r) --kk;
      else kk=-1;
    }
    if(c!='"' || re.size()<=5+2*k) err=1;
  }
  else err=1;
  if(err) 
  { yyerror(&(scanner.yylloc),&scanner,"RE error");
  }
  return re;
}
%}
}
%{
extern int bnf_flag;
extern int yyparse_flag;
extern int yylex_flag;
void generate(const string &fn, const string &fp, Program);
void switch_option(const string &o);
void add_using(const string &o);
extern string filename,filepath;
void get_args(int &, char **&);
void set_input(const char*);
#define YYARGINIT(argc,argv) get_args(argc,argv)
#define YYINIT(name) set_input(name)
}

%type <string> ?id? ?terminal? ?re? ?const? ?number? ?ref? ?lexem? ?spaces?
%type <string> type1 type2 alist
%type <Program> program
%type <Decl> decl
%type <Lrule> lrule
%type <Grule> grule
%type <Xrule> xrule
%type <Laction> lcode
%type <Term> term
%type <Symbol> symbol
%type <Gaction> rcode
%type <Gelem> elem
%type <Code> xelem
%type <Mrule> mrule
%type <Vrule> vrule
%type <Node> node

cliteral R"('([^'\\\n\t]|\\[^\n\t])+')"
sliteral R"(\"([^\"\\\n\t]|\\[^\n\t])+\")"
qliteral R"(\?[^?\n \t]+\?)"
ident [_a-zA-Z][_a-zA-Z0-9]*
number R"(\d+[a-zA-Z0-9']*|\d[0-9']*(\.[0-9']*)?([eE][-+]?\d+[a-zA-Z0-9]*)?)"
char_const R"('([^\\'\n]|\\(x[a-fA-F0-9]+|[0-9]+|.))')"
string_const R"(\"([^\\\"\n]|\\.)*\")"
%%
^"%type" "%type"
^"%code" "%code"
^"%option" "%option"
^"%using" "%using"
^"%operator" "%operator"
^{ident}                  { $$=yytext; BEGIN(S_RE2); return ?id?; }

\d+                        ?number?
<INITIAL,S_LEX2>"%{"|"{"           { yy_push_state(S_CODE);  return "%{"; }
<INITIAL,S_GRM>[a-zA-Z\xC0-\xFF\xB8\xA8][-_a-zA-Z0-9\xC0-\xFF\xB8\xA8]* ?id?
<INITIAL,S_LEX2,S_GRM,S_TOKEN>{cliteral}|{sliteral}|{qliteral} { 
            $$=yytext; if(YYSTATE==S_TOKEN) yy_pop_state(); return ?terminal?; }
[ \t]  ;
^"%%".*\n { if(yylex_flag) { BEGIN(S_LEX); caio_mode=M_LEX; return ?%%lex?; }
            if(yyparse_flag) { BEGIN(S_GRM); caio_mode=M_GRM; return ?%%grm?; }
            BEGIN(S_CODE); caio_mode=M_CODE; return ?%%code?;
          }
"//".*\n '\n'
<S_LEX2>"//".*\n { BEGIN(S_LEX); return '\n'; }
<INITIAL,S_LEX2,S_GRM,S_NODE,S_LIST,S_TERM>"/*"(.|\n)*?"*/" ;

<S_RE2>[ \t] ;
<S_RE2>\n '\n'
<S_RE2>R"(R\")" { $$=reinput(YY_SCANNER,0); BEGIN(INITIAL);  return ?re?; }
<S_RE2>. { re_str=""; yyunput(yytext[0]); BEGIN(INITIAL); yy_push_state(S_RE); }

<S_RE>\\. { re_str+=yytext; }
<S_RE>R"(\"([^\"\\\n]|\\.)*\")" { re_str+=yytext; }
<S_RE>R"(\[([^\]\\\n]|\\.)*\])" { re_str+=yytext; }
<S_RE>[ \t] { $$=re_str; yy_pop_state(); return ?re?; }
<S_RE>. { re_str+=yytext; }
<S_RE>\n { $$=re_str; yy_pop_state(); yyunput('\n'); return ?re?; }

<S_LEX>^"%%".*\n { if(yyparse_flag) { BEGIN(S_GRM); caio_mode=M_GRM; return ?%%grm?; }
                   BEGIN(S_CODE); caio_mode=M_CODE; return ?%%code?;
            }
<S_LEX>^"<"/[^<] { BEGIN(S_STATE); return '<'; }
<S_LEX2>"<" { yy_push_state(S_TERM); return '<'; }
<S_LEX>R"(R\")" { $$=reinput(YY_SCANNER,0); BEGIN(S_LEX2);
             return ?re?; 
           }
<S_LEX>[ \t] { BEGIN(S_LEX2); }
<S_LEX>[ \t]*\n '\n'
<S_LEX>. { re_str=""; yyunput(yytext[0]); BEGIN(S_LEX2); yy_push_state(S_RE); }
<S_LEX2>[ \t] ;
<S_LEX2,S_STATE>\n { BEGIN(S_LEX); return '\n'; }

<S_STATE>{ident} ?id?
<S_STATE>[ \t] ;
<S_STATE>">" { BEGIN(S_LEX); return '>'; }

<S_GRM,S_TERM>[ \t\r\n] ;
<S_TERM>">" { yy_pop_state(); return '>'; }
<S_TERM>"(" { yy_push_state(S_LIST); return '('; }
<S_TERM,S_CODE,S_LIST>{char_const} { $$=yytext; return ?const?; }
<S_TERM,S_CODE,S_LIST>{string_const} { $$=yytext; return ?const?; }
<S_TERM,S_CODE,S_LIST>R"(R\")" { $$=reinput(YY_SCANNER,1); return ?const?; }
<S_CODE>default "default"
<S_CODE>":" ':'
<S_CODE>match { yy_push_state(S_LIST); return "match"; }
<S_CODE>visitor { yy_push_state(S_NODE); return "visitor"; }
<S_CODE>R"(return/[ \t\n\r]*['\"?])" { if(caio_mode==M_LEX) yy_push_state(S_TOKEN); $$=yytext; return ?id?; }
<S_CODE>R"(token[ \t\n\r]*/['\"?])" { yy_push_state(S_TOKEN); }
<S_CODE>rule { yy_push_state(S_NODE); return "rule"; }
<S_CODE>visit { yy_push_state(S_NODE); return "visit"; }
<S_TERM,S_CODE,S_LIST>{ident} ?id?
<S_TERM,S_CODE,S_LIST>{number} ?const?
<S_LIST,S_CODE>"$$"|"@$" ?ref?
<S_TERM,S_LIST,S_CODE>"$"[0-9]+ ?ref?

<S_GRM,S_NODE,S_LIST>"//".*\n ;
<S_GRM>^"%%".*\n { BEGIN(S_CODE); caio_mode=M_CODE; return ?%%code?; }
<S_GRM>"{" { if(bnf_flag!=1) { yy_push_state(S_CODE); return "%{"; }  return '{'; }
<S_GRM>"%{" { yy_push_state(S_CODE); return "%{"; }
<S_GRM>! '|'
<S_GRM>"." ';'
<S_GRM>"(/" '['
<S_GRM>"/)" ']'
<S_GRM>"(:" '{'
<S_GRM>":)" '}'
<S_GRM>:   '='
<S_GRM>"/" '|'
<S_GRM>"<" { yy_push_state(S_TERM); return '<'; }

<S_LIST>"{" { BEGIN(S_CODE); return '{'; }
<S_LIST>")" { yy_pop_state(); return ')'; }
<S_LIST>"(" { yy_push_state(S_LIST); return '('; }
<S_LIST>[ \t\n]+ ;

<S_NODE>":" { yy_pop_state(); return ':'; }
<S_NODE>"{" { BEGIN(S_CODE); return '{'; }
<S_NODE>{ident} ?id?
<S_NODE>[ \t\n] ;

<S_CODE>"{" { yy_push_state(S_CODE); return '{'; }
<S_CODE>"}" { if(state_.size()>0) yy_pop_state(); return '}'; }
<S_CODE>"%}" { if(state_.size()>0 && yy_top_state()!=S_CODE) { yy_pop_state(); return '}';} yyunput('}'); $$="%"s; return ?lexem?; }
<S_CODE,S_TOKEN>[ \t\n]+ ?spaces?
<S_CODE>"/*".*?"*/" { $$=" "; return ?spaces?; }
<S_CODE>"/*"(.|\n)*?"*/" { $$="\n"; return ?spaces?; }
<S_CODE>"//".*\n { $$="\n"; return ?spaces?; }
<S_LIST>"," ','
<S_CODE,S_LIST>. ?lexem?
<S_TOKEN>. { yy_pop_state(); $$=yytext; return ?lexem?; }
%%
program : { [ decl ] '\n' }
          [ ?%%lex? { [lrule ] '\n' }  ] 
          [ ?%%grm? { grule ';' }  ]  
          [ ?%%code? xcode  ]          <prog($1,$2,$3,$4)>
        ;
decl : "%type" '<' type1 '>' { symbol }       <decltypes($3,$5)>
     | "%option" { ( ?id? '(' ?number? ')'    <string($1+$3)> 
                  | ?id? ) }-                 %{ for(auto o:$2) switch_option(o); }
     | "%using" { ?id? }-                     %{ for(auto o:$2) add_using(o); }
     | "%operator" { '<' ?id? '>' 
                     { ?terminal? }-          <cons($2,$4)> 
                   }-                         <decloper($2)>
     | ?id? ?re?                              <declre($1,$2)>
     | "%{" xcode '}'                         <declcode(nullptr,$2)>
     | "%code" ?id? "%{" xcode '}'            <declcode($2,$4)>
     ;
type1 : type2                                 
      | type2 '?'                             <string($1+"?"s)>
      | type2 '<' type2 '>'                   <string($1+"<"s+$3+">"s)>
      | type2 '*'                             <string($1+"*"s)>
      | type2 '<' type2 '>' '*'               <string($1+"<"s+$3+">*"s)>
      ;
type2 : ?id?                                  <string(($1=="string"s)?"std::string"s:$1)>
      | ?id? ':' ':' ?id?                     <string($1+"::"s+$4)>
      ;
symbol : ?terminal?                           <terminal($1)>
       | ?id?                                 <ident($1)>
       | ?id? '(' [ type1 { ',' type1 }       <cons($1,$2)>
                ] ')'                         <node($1,$3)>
       ;
lrule : [ '<' ( '*'                           <cons("*"s)> 
                | ?id? { ',' ?id? }           <cons($1,$2)>
              )
          '>'                                 
        ] ?re? lcode                          <lexrule($1,$2,$3)>
      ;
term : type2 '(' [ alist { ',' alist }        <cons($1,$2)>
                 ] ')'                        <tnode($1,$3)>
     | ?const?                                <snode($1)>
     | type2                                  <snode($1)>
     | ?ref?                                  <snode($1)>
     ;
lcode : [ ?terminal? ] [ '<' term '>' ]       <lterm($1,$2)>
      | ';'                                   <lskip()>
      | '|'                                   <lnext()>
      | "%{" xcode '}'                        <lcode($2)>
      ;
alist : lelem                                 %{ string s; for(auto x:$1) s+=x; $$=s; }
      | alist lelem                           %{ string s; for(auto x:$2) s+=x; $$=$1+s; }
      ;

grule : ?id? '=' erule                        <grmrule($1,$3)>
      ;
erule : xrule { '|' xrule }                   <cons($1,$2)>
      ;
xrule : { elem [ ',' ] } rcode                <xrule($1,$2)>
      ;
rcode :                                       <gempty()>
      | '<' term '>'                          <gterm($2)>
      | "%{" xcode '}'                        <gcode($2)>
      ;
elem : ?terminal?                             <trmelem($1)>
     | ?id?                                   <symelem($1)>
     | '(' erule ')'                          <varelem($2)>
     | '(' erule ')' '*'                      <repelem0($2)>
     | '{' erule '}'                          <repelem0($2)>
     | '(' erule ')' '+'                      <repelem1($2)>
     | '{' erule '}' '-'                      <repelem1($2)>
     | '(' erule ')' '?'                      <optelem($2)>
     | '[' erule ']'                          <optelem($2)>
     ;
xcode : { ( xelem 
          | "default"                         <lexem("default"s)> 
          ) }
      ;
ncode : { xelem }
      ;
xelem : ?lexem?                               <lexem($1)>
      | ?const?                               <lexem($1)>
      | ?id?                                  <lexem($1)>
      | ':'                                   <lexem(":"s)>
      | ?ref?                                 <lexem($1)>
      | ?spaces?                              <lexem($1)>
      | '{' xcode '}'                         <pcode($2)>
      | "match" list '{' 
            { ?spaces? } 
            ( { mrule }-
              [ "default" ':' ncode           <mrule(nullptr,$3)>
              ]                               <cons($1,$2)>
            ) 
         '}'                                  <mcode($2,$5)>
      | "visitor" ?id? '<' ?id? ',' ?id? '>' 
        '{' xcode 
            { vrule }-
        '}'                                   <vcode($2,$4,$6,$9,$10)>
      | ?terminal?                            <token($1)>
      ;
mrule : "rule" node ':' ncode                 <mrule($2,$4)>
      ;
vrule : "visit" node ':' ncode                <vrule($2,$4)>
      ;
list : lelem { ( lelem | ','                  <cons(","s)> 
               ) }                            <cons($1,$2)>
     ;
lelem : ?lexem?                               <cons($1)>
      | ?ref?                                 <cons($1)>
      | ?id?                                  <cons($1)>
      | ?const?                               <cons($1)>
      | '(' list ')'                          <cons(cons("("s,$2),")"s)>
      ;
node : ?id? '(' [ ?id? { ',' ?id? }           <cons($1,$2)>
              ] ')'                           <node2($1,$3)>
     | ?id?                                   <node1($1)>
     ;
%%
void get_args(int &yyargc, char **&yyargv)
{ for(int i=1;i<yyargc;++i)
    if(yyargv[i][0]=='-' && yyargv[1][1]=='o')
      filepath=yyargv[i]+2;
}
int bnf_flag=1;
int ast_flag=0;
int case_flag=0;
int inter_flag=0;
int main_flag=1;
int locations_flag=0;
int literal_flag=1;
int yywrap_flag=0;
int matcherr_flag=1;
int astprint_flag=1;
int lexprint_flag=0;
int yyparse_flag=1;
int visitor_flag=1;
int yylex_flag=1;
int yyerror_flag=1;
int expect_flag=-1;
int yyinterpret_flag=1;
int usevalue_flag=0;
int usestring_flag=0;
int uselist_flag=0;
int reentrant_flag=0;
int lexdefault_flag=-1;
int line_flag=1;

int grmfile_exist=0;
int lexfile_exist=0;

int gen_mode=0;
int return_field=0;

int symbol_uid=0;
int terminal_uid=1000;
string filename,filepath;
string root_tip;

struct symbolinfo {
  string altname;
  int generated;
  int terminalnumber;
  string tip;
  Grule defrule;
  int used;
  vector<pair<string,int>> node_link;
  vector<pair<string,int>> symbol_link;
  symbolinfo():altname(""s),generated(0),terminalnumber(0),tip(""),defrule(nullptr),used(0){}
};
struct constinfo {
  string tip;
  constinfo():tip(""){}
};
struct nodeinfo {
  vector<string> types;
  vector<string> symbol_link;
  nodeinfo(int n=0):types(n){}
};
struct domaininfo {
  set<string> nodes;
  domaininfo(){}
};
struct operinfo {
  string name;
  string tip;
  int prior;
  operinfo(const string &name, const string &tip, int prior):name(name),tip(tip),prior(prior){}
};
struct lexdefinfo {
  string id;
  string re;
  lexdefinfo(const string &id, const string&re):id(id),re(re) {}
};
map<string,symbolinfo> symbols;
map<string,constinfo> consts;
map<string,domaininfo> domains;
map<string,nodeinfo> nodes;
vector<operinfo> opers;
vector<lexdefinfo> lexdefs;
set<string> defined_symbols;
set<string> symbol_names;
set<string> lex_states;
map<string,int> union_fields;
ostringstream vout;
string default_tip="int"s;
vector<string> using_list;

void set_input(const char* name)
{
  bnf_flag=1;
  ast_flag=0;
  case_flag=0;
  inter_flag=0;
  main_flag=1;
  locations_flag=0;
  literal_flag=1;
  yywrap_flag=0;
  matcherr_flag=1;
  astprint_flag=1;
  lexprint_flag=0;
  yyparse_flag=1;
  visitor_flag=1;
  yylex_flag=1;
  yyerror_flag=1;
  expect_flag=-1;
  yyinterpret_flag=1;
  usevalue_flag=0;
  usestring_flag=0;
  uselist_flag=0;
  reentrant_flag=0;
  lexdefault_flag=-1;
  line_flag=1;

  grmfile_exist=0;
  lexfile_exist=0;

  gen_mode=0;
  return_field=0;

  symbol_uid=0;
  terminal_uid=1000;
  root_tip=""s;
  caio_mode=M_DECL;

  symbols.clear();
  consts.clear();
  domains.clear();
  nodes.clear();
  opers.clear();
  lexdefs.clear();
  defined_symbols.clear();
  symbol_names.clear();
  lex_states.clear();
  union_fields.clear();
  vout.clear();
  default_tip="int"s;
  using_list.clear();
  
  filename=name;
  size_t p=filename.rfind('/');
  if(p!=string::npos) filename=filename.substr(p+1);
  p=filename.rfind('\\');
  if(p!=string::npos) filename=filename.substr(p+1);
  p=filename.rfind('.');
  if(p!=string::npos) filename=filename.substr(0,p);
}

void add_using(const string &o)
{ using_list.push_back(o);
}
void switch_option(const string &o)
{
   if(o=="ebnf"s)
     bnf_flag=1;
   else if(o=="bnf"s)
     bnf_flag=0;
   else if(o=="rebnf"s)
     bnf_flag=2;
   else if(o=="aebnf"s)
     bnf_flag=3;
   else if(o=="case-insensitive"s)
     case_flag=1;
   else if(o=="case-sensitive"s)
     case_flag=0;
   else if(o=="interactive"s)
     inter_flag=1;
   else if(o=="nointeractive"s)
     inter_flag=0;
   else if(o=="nomain"s)
     main_flag=0;
   else if(o=="main"s)
     main_flag=1;
   else if(o=="noyyparse"s)
     yyparse_flag=0;
   else if(o=="yyparse"s)
     yyparse_flag=1;
   else if(o=="noyylex"s)
     yylex_flag=0;
   else if(o=="yylex"s)
     yylex_flag=1;
   else if(o=="reentrant"s)
     reentrant_flag=1;
   else if(o=="yylineno"s)
     locations_flag=1;
   else if(o=="locations"s)
     locations_flag=2;
   else if(o=="nolocations"s)
     locations_flag=0;
   else if(o=="literal-rules"s)
     literal_flag=1;
   else if(o=="noliteral-rules"s)
     literal_flag=0;
   else if(o=="nodefault"s)
     lexdefault_flag=0;
   else if(o=="default-skip"s)
     lexdefault_flag=2;
   else if(o=="default-literal"s)
     lexdefault_flag=3;
   else if(o=="default-echo"s)
     lexdefault_flag=1;
   else if(o=="yywrap"s)
     yywrap_flag=1;
   else if(o=="noyywrap"s)
     yywrap_flag=0;
   else if(o=="matcherror"s)
     matcherr_flag=1;
   else if(o=="nomatcherror"s)
     matcherr_flag=0;
   else if(o=="visitor"s)
     visitor_flag=2;
   else if(o=="novisitor"s)
     visitor_flag=0;
   else if(o=="yyinterpret"s)
     yyinterpret_flag=1;
   else if(o=="noyyinterpret"s)
     yyinterpret_flag=0;
   else if(o=="astprint"s)
     astprint_flag=1;
   else if(o=="noastprint"s)
     astprint_flag=0;
   else if(o=="lexprint"s)
     lexprint_flag=1;
   else if(o=="nolexprint"s)
     lexprint_flag=0;
   else if(o=="yyerror"s)
     yyerror_flag=1;
   else if(o=="noyyerror"s)
     yyerror_flag=0;
   else if(o=="line"s)
     line_flag=1;
   else if(o=="noline"s)
     line_flag=0;
   else if(o=="ast"s)
   {
     main_flag=0;
     yylex_flag=0;
     yyparse_flag=0;
     ast_flag=1;
     locations_flag=0;
   }
   else if(o.substr(0,6)=="expect"s)
     expect_flag=stoi(o.substr(6));
}
set<string> builtin_types={"int"s,"std::string"s,"long"s,"double"s,"int64_t"s,"char"s};
bool is_pointer_type(const string &t)
{
  return t[t.size()-1]=='*';
}
bool is_builtin_type(const string &t)
{ 
  return builtin_types.find(t)!=builtin_types.end();
}
bool is_big_builtin_type(const string &t)
{ 
  return t=="std::string"s;
}
bool is_domain(const string &s)
{ return domains.find(s)!=domains.end();
}
bool is_domain_name(const string &s)
{
  for(auto c:s)
    if(!isalnum(c)) return 0;
  return !is_builtin_type(s);
}
bool is_list_type(const string &s)
{ return s.substr(0,5)=="List<"s;
}
string list_of_type(string s)
{ if(s.back()=='?') s.pop_back();
  return "List<"s+s+">"s;
}
string type_of_list(const string &s)
{ if(s.substr(0,5)=="List<"s) return s.substr(5,s.size()-6);
  return s;
}
bool empty_type(const string& t)
{ return t==""s || t=="?"s;
}
string encode_string(const string &s, int enc_hex=1)
{ string r;
  for(auto c:s)
  { if(c=='\n') r+="\\n";
    else if(c=='\t') r+="\\t";
    else if(c=='\\' || c=='\'' || c=='\"') { r+='\\'; r+=c; }
    else if((c&0xFF)>=0x7F && enc_hex) { 
      r+="\\x"s; 
      ostringstream v;
      v<<hex<<(c&0xFF);
      r+=v.str();
    }
    else
      r+=c;
  }
  return r;
}
static int todigit(char c)
{ if(c>='0' && c<='9')
     return c-'0';
   else if(c>='a' && c<='f')
      return c-'a'+10;
   else if(c>='A' && c<='F')
      return c-'A'+10;
   return 0;
}
string decode_string(const string&t)
{ string s="";
  for(int i=0;i<t.size();++i)
  { if(i+1<t.size() && t[i]=='\\' && t[i+1]=='n')
    { ++i; s+='\n';
    }
    else if(i+1<t.size() && t[i]=='\\' && t[i+1]=='t')
    { ++i; s+='\t';
    }  
    else if(i+3<t.size() && t[i]=='\\' && t[i+1]=='x' && isxdigit(t[i+2]) && isxdigit(t[i+3]))
    {
      s+=char(todigit(t[i+2])*16+todigit(t[i+3]));
      i+=3;
    }
    else
      s+=t[i];
  }
  return s;
}
string normalize_terminal(const string &t)
{ if(t[0]=='?') return t;
  string s=decode_string(t.substr(1,t.size()-2));
  if(s.size()==1) return "'"s+encode_string(s)+"'"s;
  return "\""s+encode_string(s)+"\""s;
}
bool isterminal(const string &o)
{ return o[0]=='?' || o[0]=='\'' || o[0]=='\"';
}
bool isliteral(const string &o)
{ return o[0]=='\'' || o[0]=='\"';
}
const char* cyr_enc[32]={
      "a","b","v","g","d","e","zh","z","i","y","k","l","m","n","o",
      "p","r","s","t","u","f","kh","ts","ch","sh","tsh","q","iq","j","eq","yu","ya"};
string encode_symbol(const string &sym)
{ string r,s;
  for(auto c:sym)
  { int ch=c&0xFF;
    if(ch>=224)
      s=cyr_enc[ch-224];
    else if(ch>=192)
    { s=cyr_enc[ch-192];
      s[0]=toupper(s[0]);
    }
    else if(ch=='-')
      s="_";
    else if(ch==168)
      s="Yo";
    else if(ch==184)
      s="yo";
    else
      s=string(1,c);
    r+=s;
  }
  return r;
}
int oper_prior(const string &o, int n)
{ string op=normalize_terminal(o);
  for(auto &x:opers)
    if(x.name==op)
    { if(n==2) 
      { if(x.tip=="xfx"s || x.tip=="xfy"s || x.tip=="yfx") return x.prior;
      }
      else if(n==1)
      { if(x.tip=="fx" || x.tip=="fy") return x.prior;
      }
      else
      { if(x.tip=="xf" || x.tip=="yf") return x.prior;
      }
    }
  return 0;
}
string oper_type(const string &o, int n)
{ string op=normalize_terminal(o);
  for(auto &x:opers)
    if(x.name==op)
    { if(n==2) 
      { if(x.tip=="xfx"s || x.tip=="xfy"s || x.tip=="yfx") return x.tip;
      }
      else if(n==1)
      { if(x.tip=="fx" || x.tip=="fy") return x.tip;
      }
      else
      { if(x.tip=="xf" || x.tip=="yf") return x.tip;
      }
    }
  return ""s;
}
string type_mark(const string &t, int cf)
{ if(t.back()=='?')
    return "ast::Value<"s+t.substr(0,t.size()-1)+">"s;
  if(is_big_builtin_type(t) && cf==1) 
    return "const "s+t+"&";
  return t;
}
void gen_coderef(ostream& fout, const string &t, int mlevel, int limit)
{ 
  if(t=="$$"s)
  {
    if(gen_mode==0 && mlevel==0)
      yyerror("Can't use $$ without rule"s);
    else if(gen_mode==0)
      fout<<"(*_node"<<mlevel<<")";
    else if(gen_mode==1)
      fout<<"yylval.f"<<return_field<<"_";
    else
      fout<<t;
  }
  else if(t=="@$"s)
  {
    if(gen_mode==0 && mlevel==0 || locations_flag!=2)
      yyerror("Can't use @$ without rule or locations option"s);
    else if(gen_mode==0)
      fout<<"(_node"<<mlevel<<"->yyloc)";
    else if(gen_mode==1)
      fout<<"(yylloc)";
    else
      fout<<t;
  }
  else if(t.size()>=2 && t[0]=='$' && t[1]>='1' && t[1]<='9')
  { int n=stoi(t.substr(1));
    if(n<1 || n>limit)
      yyerror(t+" don't exist"s);
    if(gen_mode==0)
      fout<<"_node"<<mlevel<<"->f"<<t.substr(1)<<"_";
    else
      fout<<t;
  }
  else
    fout<<t;
}
void show_line(ostream& fout, int l, int c)
{
    if(line_flag==0 || l<=1) return;
    fout<<"\n\t#line "<<l<<" \""<<yyinputfile<<"\"\n";
    if(c<=0) c=2;
    while(--c>0) fout<<' ';
}
void gen_code_line(ostream& fout, List<Code> code, int mlevel,int limit);
void gen_code(ostream& fout, List<Code> code, int mlevel,int limit)
{ for(auto c:code)
  match c 
  { rule lexem(t): 
      gen_coderef(fout,t,mlevel,limit);
    rule pcode(cc):
      fout<<"{";
      gen_code(fout,cc,mlevel,limit);
      fout<<"}";
    rule mcode(cc,rules):
      { int old_mode=gen_mode;
        gen_mode=0;
        fout<<"{ auto &_match"<<(mlevel+1)<<"=";
        for(auto s:cc)
        { gen_coderef(fout,s,mlevel,limit);
        } 
        fout<<";\n";
        int flg=0,dflt=0;
        for(auto r:rules)
        {          
          match r {
            rule mrule(m, co):
            { int nlimit=0,mtip=0;
              List<string> a(nullptr);
              string idn;
              match m {
                rule nullptr:
                  idn=""s;
                  mtip=1;
                rule node2(id,args):
                  { idn=id;
                    a=args;
                  }
                rule node1(id):
                  { mtip=1;
                    idn=id;
                  }
              }
              if(idn=="nullptr"s)
              { if(flg) yyerror("rule nullptr should be first in match"s);
                nlimit=0;
              }
              else if(idn=="")
              { 
                nlimit=0;
                dflt=1;
              }
              else
              {
                auto it=nodes.find(idn);
                if(it==nodes.end() && using_list.size()==0)
                  yyerror("Node "s+idn+" don't exist"s);
                if(mtip==0) 
                { int n=0;
                  for(auto x:a) ++n;
                  if(it!=nodes.end() && n!=it->second.types.size()-1)
                    yyerror("Node "s+idn+"' args can't matched"s);
                  nlimit=0;
                }
                else
                { if(it!=nodes.end())
                    nlimit=it->second.types.size()-1;
                  else 
                    nlimit=100;
                }
              }
              if(flg) fout<<"else ";
              if(idn=="nullptr"s)
                fout<<"if(_match"<<(mlevel+1)<<"==nullptr) {\n";
              else if(idn==""s)
                fout<<" {\n";
              else 
                fout<<"if(auto _node"<<(mlevel+1)<<"=dynamic_cast<"<<idn<<"_node *>(_match"<<(mlevel+1)<<")) {\n";
              int n=0;
              for(auto f:a)
              { ++n;
                fout<<"  auto &"<<f<<"=_node"<<(mlevel+1)<<"->f"<<n<<"_;\n";
              }
              gen_code_line(fout,co,mlevel+1,nlimit);
              fout<<"}\n";
              flg=1;
            }
          }
        }
        if(!dflt && matcherr_flag)
        {  if(flg) fout<<"else ";
           fout<<"{ yyerror(\""<<yyinputfile<<":"<<@$.last.line<<":"<<@$.last.column<<": Match error\"); }\n";
        }
        fout<<"}\n";
        show_line(fout,@$.last.line,@$.last.column);

        gen_mode=old_mode;
      }
    rule vcode(id,tip,ret,cc,rules):
      { if(gen_mode!=0 || mlevel>0)
          yyerror("Can't define visitor at this point"s);
        if(visitor_flag==0)
          yyerror("Visitor is disabled"s);
        visitor_flag=2;
        int old_mode=gen_mode;
        gen_mode=0;
        fout<<"struct "<<id<<"_visitor:"<<tip<<"_Tvisitor<"<<ret<<"> {\n";
        gen_code_line(fout,cc,mlevel+1,0);
        fout<<"\n";
        for(auto r:rules)
        {          
          match r {
            rule vrule(m, co):
            { int nlimit=0,mtip=0;
              List<string> a(nullptr);
              string idn;
              match m {
                rule node2(idt,args):
                  { idn=idt;
                    a=args;
                  }
                rule node1(idt):
                  { mtip=1;
                    idn=idt;
                  }
              }
              auto it=nodes.find(idn);
              if(it==nodes.end() && using_list.size()==0)
                yyerror("Node "s+idn+" don't exist"s);
              if(mtip==0) 
              { int n=0;
                for(auto x:a) ++n;
                if(it!=nodes.end() && n!=it->second.types.size()-1)
                  yyerror("Node "s+idn+"' args can't matched"s);
                nlimit=0;
              }
              else
              { if(it!=nodes.end())
                  nlimit=it->second.types.size()-1;
                else
                  nlimit=100;
              }
              fout<<ret<<" visit("<<idn<<"_node*);\n";
              vout<<ret<<" "<<id<<"_visitor::visit("<<idn<<"_node* _node"<<(mlevel+1)<<") {\n";
              int n=0;
              for(auto f:a)
              { ++n;
                vout<<"  auto &"<<f<<"=_node"<<(mlevel+1)<<"->f"<<n<<"_;\n";
              }
              gen_code_line(vout,co,mlevel+1,nlimit);
              vout<<"}\n";
            }
          }
        }
        fout<<"} "<<id<<";\n";
        show_line(fout,@$.last.line,@$.last.column);
        gen_mode=old_mode;
      }
    rule token(val):
      { string id=normalize_terminal(val);
        auto it=symbols.find(id);
        if(it==symbols.end())
          yyerror(id+" isn't used in rules");
        if(it->second.terminalnumber>0)
          fout<<"("<<it->second.terminalnumber<<")";
        else 
          fout<<"("<<it->second.altname<<")";
      }
  }
}
void gen_code_line(ostream& fout, List<Code> code, int mlevel,int limit)
{ if(code)
  { 
    show_line(fout,code[0]->yyloc.first.line,code[0]->yyloc.first.column);
    gen_code(fout,code,mlevel,limit);
  }
}
void add_symbol(const string&id, const string&tip)
{ if(symbols.find(id)!=symbols.end()) return;
  symbols[id]=symbolinfo();
  symbols[id].tip=tip;
}
void add_constant(const string&id, const string&tip)
{ if(consts.find(id)!=consts.end()) return;
  consts[id]=constinfo();
  consts[id].tip=tip;
}
List<Code> hcode(nullptr);
List<Code> grmcode(nullptr);
List<Code> lexcode(nullptr);
void collect_terminals(List<Code> code)
{ for(auto c:code)
  match c 
  { rule pcode(cc):
      collect_terminals(cc);
    rule token(val):
      add_symbol(normalize_terminal(val),"");
  }
}
void collect_decls(List<Decl> decls)
{ int prior=0;
  string tip="";
  for(auto d:decls)
  { match d {
    rule decloper(ops):
      prior++; 
      for(auto o:ops)
      { if(isterminal(o))
          opers.push_back(operinfo(normalize_terminal(o),tip,prior));
        else
          tip=o;
      }
    rule decltypes(tip, syms):
      if(is_domain_name(tip)) {
        if(!is_domain(tip))
          domains[tip]=domaininfo();
      }
      if(!syms)  default_tip=tip;
      for(auto sym:syms)
      { match sym {
        rule terminal(id):
          add_symbol(normalize_terminal(id),tip);
        rule ident(id):
        {
          if(defined_symbols.find(id)!=defined_symbols.end())
            add_symbol(id,tip);
          else
            add_constant(id,tip);
        }
        rule node(id, args):
          if(!is_domain_name(tip))
            yyerror("Type of node can't assign to "s+tip);
          if(nodes.find(id)!=nodes.end())
            yyerror("Node "s+id+" is assigned to domain "s+nodes[id].types[0]);
          auto &v=nodes[id];
          v.types.push_back(tip);
          for(auto &t:args)
          { if(t.back()=='?')
              if(!is_builtin_type(t.substr(0,t.size()-1)))
                yyerror("Wrong type "s+t);
            v.types.push_back(t);
          }
          domains[tip].nodes.insert(id);
        }
      }
    rule declcode(dest,cc):
      if(!dest || dest=="h"s)
        hcode=cons(hcode,cc);
      else if(dest=="grm"s)
        grmcode=cons(grmcode,cc);
      else if(dest=="lex"s)
        lexcode=cons(lexcode,cc);
      collect_terminals(cc);
    rule declre(id,re):
      lexdefs.push_back(lexdefinfo(id,re));
    }
  }
}
void collect_terminals(List<Lrule> rules)
{ for(auto r:rules)
  {
    match r {
    rule lexrule(sts, re, act):
       match act {
       rule lterm(id,t):
          if(id)
            add_symbol(normalize_terminal(id),"");
       }
       rule lcode(cc):
         collect_terminals(cc);
    }
  }
}
regex ref_re(R"(\$(\d+))");
void collect_ref(const string& t, set<int>& refs)
{ 
  for(auto it=sregex_iterator(t.begin(),t.end(),ref_re);
     it!=sregex_iterator();++it) 
  { refs.insert(stoi(it->str(1)));
  }
}
void collect_refs(Term t, set<int>& refs)
{ match t {
    rule tnode(id, args):
    { for(auto a:args)
        collect_ref(a,refs);
    }
    rule snode(str): 
      collect_ref(str,refs);
  }
}
void collect_refs(List<Code> code, set<int>& refs)
{ for(auto c:code)
  match c 
  { rule pcode(cc):
      collect_refs(cc,refs);
    rule lexem(val):
      collect_ref(val,refs);
  }
}
void collect_terminals(List<Xrule> rules)
{ for(auto r:rules)
  { set<int> refs;
    match r {
    rule xrule(elist, a):
      match a {
      rule gterm(t):
        collect_refs(t,refs);
      rule gcode(cc):
        collect_terminals(cc);
        collect_refs(cc,refs);
      }
      int n=0;
      for(auto e:elist)
      { ++n;
        bool flg=refs.find(n)!=refs.end();
        match e {
        rule trmelem(id): 
          add_symbol(normalize_terminal(id),"");
        rule symelem(id):
          if(flg)
            symbols[id].used=true;
        rule varelem(xl):
          collect_terminals(xl);
        rule optelem(xl):
          collect_terminals(xl);
        rule repelem1(xl):
          collect_terminals(xl);
        rule repelem0(xl):
          collect_terminals(xl);
        }
      }
    }
  }
}
void collect_terminals(List<Grule> rules)
{ for(auto r:rules)
  { match r {
    rule grmrule(id, body):
      collect_terminals(body);
    }
  } 
}
bool is_empty_rule(List<Xrule> rules)
{
  for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      match a {
      rule gempty():
        for(auto e:elist)
        {
          match e {
          rule trmelem(id):
            if(!empty_type(symbols[normalize_terminal(id)].tip)) return false;
          rule varelem(xl):
            if(!is_empty_rule(xl)) return false;
          rule optelem(xl):
            if(!is_empty_rule(xl)) return false;
          rule repelem1(xl):
            if(!is_empty_rule(xl)) return false;
          rule repelem0(xl):
            if(!is_empty_rule(xl)) return false;
          default:
            return false;
          }
        }
      default:
        return false;
      }
    }
  }
  return true;
}
void setup_default(List<Xrule> rules, bool need)
{ 
  for(auto r:rules)
  { set<int> refs;
    match r {
    rule xrule(elist, a):
      match a {
      rule gempty():
        if(need)
        { int k=0,i=0;
          int n=0;
          for(auto e:elist)
          { ++n;
            match e {
            rule trmelem(id):
              if(!empty_type(symbols[normalize_terminal(id)].tip))
              { i=n; ++k;
              }
            rule varelem(xl):
              if(!is_empty_rule(xl))
              { i=n; ++k;
              }
            rule optelem(xl):
              if(!is_empty_rule(xl))
              { i=n; ++k;
              }
            rule repelem1(xl):
              if(!is_empty_rule(xl))
              { i=n; ++k;
              }
            rule repelem0(xl):
              if(!is_empty_rule(xl))
              { i=n; ++k;
              }
            default:
              { i=n; ++k; 
              }
            }
          }
          if(k==1) {
            destroy(a); a=gterm(snode("$"s+to_string(i)));
            refs.insert(i);
          }
          else if(k>1)
            std::cerr<<"Warning: ambiguity rule to select value by default, write direct action\n";
        }
      rule gterm(t):
        collect_refs(t,refs);
      rule gcode(cc):
        collect_refs(cc,refs);
      }
      int n=0;
      for(auto &e:elist)
      { ++n;
        bool flg=refs.find(n)!=refs.end();
        match e {
        rule trmelem(id):
          if(flg)
            if(empty_type(symbols[normalize_terminal(id)].tip))
              std::cerr<<"Warning: ref to terminal "<<id<<" with undefined type\n";
        rule symelem(id): 
          if(flg) 
          { if(!symbols[id].used)
            {
              symbols[id].used=true;
              match symbols[id].defrule {
              rule grmrule(id2, body2):
                setup_default(body2, true);
              }
            }
          }
        rule varelem(xl):
          setup_default(xl,flg);
        rule optelem(xl):
          setup_default(xl,flg);
        rule repelem1(xl):
          setup_default(xl,flg);
        rule repelem0(xl):
          setup_default(xl,flg);
        }
      }
    }
  }
}
void setup_default(List<Grule> rules)
{ for(auto r:rules)
  { match r {
    rule grmrule(id, body):
      if(!empty_type(symbols[id].tip))
        symbols[id].used=true;
      setup_default(body, symbols[id].used);
    }
  } 
}
void collect_states(List<Lrule> rules)
{ for(auto r:rules)
  {
    match r {
    rule lexrule(sts, re, act):
      for(auto s:sts)
      { if(s!="*"s && s!="INITIAL")
        { lex_states.insert(s);
        }
      }
    }
  }
}
void collect_defsymbols(List<Grule> rules)
{ for(auto r:rules)
  { match r {
    rule grmrule(id, body):
       if(defined_symbols.find(id)!=defined_symbols.end())
         yyerror("Redefined symbol "s+id);
       defined_symbols.insert(id);
    }
  }
}
void check_undefsymbols(List<Xrule> rules)
{ for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      for(auto e:elist)
      { match e {
        rule trmelem(id): ;
        rule symelem(id): 
        { if(defined_symbols.find(id)==defined_symbols.end())
            yyerror("Undefined symbol "s+id);
        }
        rule varelem(xl):
          check_undefsymbols(xl);
        rule optelem(xl):
          check_undefsymbols(xl);
        rule repelem1(xl):
          check_undefsymbols(xl);
        rule repelem0(xl):
          check_undefsymbols(xl);
        }
      }
    }
  }
}
void check_undefsymbols(List<Grule> rules)
{ for(auto r:rules)
  { match r {
    rule grmrule(id, body):
      check_undefsymbols(body);
    }
  }
}
List<Grule> new_rules=nullptr;
string new_symbol()
{ string id;
  do {
    id="g_"s+to_string(++symbol_uid);
  } while(symbol_names.find(id)!=symbol_names.end());
  add_symbol(id,"");
  return id;
}
bool is_symelem(Gelem e, const string &id)
{ bool res=false;
  match e {
    rule symelem(s): if(s==id) res=true;
  }
  return res;
}
bool is_trmelem(Gelem e)
{ bool res=false;
  match e {
    rule trmelem(s): res=true;
  }
  return res; 
}
int prior_elem(Gelem e, int n)
{
  int res=0;
  match e {
    rule trmelem(s): res=oper_prior(s,n);
    rule varelem(xl):
       res=100;
       for(auto x:xl)
       { match x {
         rule xrule(elist, a):
           if(elist.size()!=1) return 0;
           if(!is_trmelem(elist[0])) return 0;
           int p=prior_elem(elist[0],n);
           if(p==0 && n==2) return 0;
           if(p>0 && res>p) res=p;
         }
       }
  }
  return res;
}
string type_elem(Gelem e, int n)
{
  string res=""s;
  match e {
    rule trmelem(s): res=oper_type(s,n);
  }
  return res;
}
bool is_operrule(Xrule x, int prior, int n, const string &tip)
{ 
  match x {
  rule xrule(elist, a):
    if(elist.size()!=1) return false;
    if(!is_trmelem(elist[0])) return false;
    return prior_elem(elist[0],n)==prior && type_elem(elist[0],n)==tip;
  }
  return false;
}
struct copy_xrule_node : xrule_node {
	copy_xrule_node(List<Gelem> a1, Gaction a2):xrule_node(a1,a2){}
	~copy_xrule_node() {
          f2_=nullptr;
	}
};
inline Xrule copy_xrule(List<Gelem> a1, Gaction a2) {
	return new copy_xrule_node(a1, a2);
}

void reorder_body(const string &gid, const string &id, List<Xrule> &rules)
{ int min_prior=100;
  for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      if(elist.size()==3 && is_symelem(elist[0],id) && is_symelem(elist[2],id))
      { int p=prior_elem(elist[1],2);
        if(p==0) yyerror("Wrong rule for "s+gid);
        if(min_prior>p) min_prior=p;
      }
      else if(elist.size()==2 && is_symelem(elist[1],id))
      { int p=prior_elem(elist[0],1);
        if(p>0 && min_prior>p) min_prior=p;
        if(p==0 && is_symelem(elist[0],id)) yyerror("Wrong rule for "s+gid);
      }
      else if(elist.size()==2 && is_symelem(elist[0],id))
      { int p=prior_elem(elist[1],0);
        if(p>0 && min_prior>p) min_prior=p;
      }
    }
  }
  if(min_prior==100) return;
  // разделить по приоритету
  List<Xrule> rules1=nullptr;
  List<Xrule> rules2=nullptr;
  string id1(new_symbol());
  for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      if(elist.size()==3 && is_symelem(elist[0],id) && is_symelem(elist[2],id))
      { int p=prior_elem(elist[1],2);
        if(p>min_prior)
        { destroy(elist[0]); elist[0]=symelem(id1); 
          destroy(elist[2]); elist[2]=symelem(id1);
          rules2=cons(rules2,r);
        }
        else
        { 
          if(is_trmelem(elist[1]))
          {
            string t=type_elem(elist[1],2);
            if(t[0]=='x') { destroy(elist[0]); elist[0]=symelem(id1); }
            if(t[2]=='x') { destroy(elist[2]); elist[2]=symelem(id1); }
            rules1=cons(rules1,r);
          }
          else
          { List<Xrule> part1=nullptr;
            match elist[1] {
            rule varelem(xl):
              part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,2,"xfx"s);} );
              if(!xl)
              { 
                destroy(elist[0]); elist[0]=symelem(id1);
                destroy(elist[2]); elist[2]=symelem(id1);
                xl=part1;
                rules1=cons(rules1,r);
              }
              else 
              { if(part1)
                { rules1=cons(rules1,copy_xrule(List<Gelem>({symelem(id1),varelem(part1),symelem(id1)}),a));
                }
                part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,2,"xfy"s);} );
                if(!xl)
                { 
                  destroy(elist[0]); elist[0]=symelem(id1);
                  xl=part1;
                  rules1=cons(rules1,r);
                }
                else
                {
                  if(part1)
                  { rules1=cons(rules1,copy_xrule(List<Gelem>({symelem(id1),varelem(part1),symelem(id)}),a));
                  }
                  part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,2,"yfx"s);} );
                  if(!xl)
                  { 
                    destroy(elist[2]); elist[2]=symelem(id1);
                    xl=part1;
                    rules1=cons(rules1,r);
                  }
                  else
                  {
                    if(part1)
                    { rules1=cons(rules1,copy_xrule(List<Gelem>({symelem(id),varelem(part1),symelem(id1)}),a));
                    }
                    rules2=cons(rules2,r);
                    destroy(elist[0]); elist[0]=symelem(id1);
                    destroy(elist[2]); elist[2]=symelem(id1);
                  }    
                }    
              }
            }
          }
        }
      }
      else if(elist.size()==2 && is_symelem(elist[1],id))
      { int p=prior_elem(elist[0],1);
        if(p==0)
        { rules2=cons(rules2,r);
        }
        else if(p>min_prior)
        { rules2=cons(rules2,r);
          destroy(elist[1]); elist[1]=symelem(id1);
        }
        else
        { 
          if(is_trmelem(elist[0]))
          {
            string t=type_elem(elist[0],1);
            if(t[1]=='x') { destroy(elist[1]); elist[1]=symelem(id1); }
            rules1=cons(rules1,r);
          }
          else
          { List<Xrule> part1=nullptr;
            match elist[0] {
            rule varelem(xl):
              part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,1,"fx"s);} );
              if(!xl)
              { 
                destroy(elist[1]); elist[1]=symelem(id1);
                xl=part1;
                rules1=cons(rules1,r);
              }
              else 
              { if(part1)
                { rules1=cons(rules1,copy_xrule(List<Gelem>({varelem(part1),symelem(id1)}),a));
                }
                part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,1,"fy"s);} );
                if(!xl)
                { 
                  xl=part1;
                  rules1=cons(rules1,r);
                }
                else
                {
                  if(part1)
                  { rules1=cons(rules1,copy_xrule(List<Gelem>({varelem(part1),symelem(id)}),a));
                  }
                  rules2=cons(rules2,r);
                  destroy(elist[1]); elist[1]=symelem(id1);
                }    
              }
            }
          }
        }
      }
      else if(elist.size()==2 && is_symelem(elist[0],id))
      { int p=prior_elem(elist[1],0);
        if(p==0)
        { rules2=cons(rules2,r);
        }
        else if(p>min_prior)
        { rules2=cons(rules2,r);
          destroy(elist[0]); elist[0]=symelem(id1);
        }
        else
        { 
          if(is_trmelem(elist[1]))
          {
            string t=type_elem(elist[1],0);
            if(t[0]=='x') { destroy(elist[0]); elist[0]=symelem(id1); }
            rules1=cons(rules1,r);
          }
          else
          { List<Xrule> part1=nullptr;
            match elist[1] {
            rule varelem(xl):
              part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,0,"xf"s);} );
              if(!xl)
              { 
                destroy(elist[1]); elist[1]=symelem(id1);
                xl=part1;
                rules1=cons(rules1,r);
              }
              else 
              { if(part1)
                { rules1=cons(rules1,copy_xrule(List<Gelem>({symelem(id1),varelem(part1)}),a));
                }
                part1=xl.split([=](Xrule x) { return is_operrule(x,min_prior,0,"yf"s);} );
                if(!xl)
                { 
                  xl=part1;
                  rules1=cons(rules1,r);
                }
                else
                {
                  if(part1)
                  { rules1=cons(rules1,copy_xrule(List<Gelem>({symelem(id),varelem(part1)}),a));
                  }
                  rules2=cons(rules2,r);
                  destroy(elist[0]); elist[0]=symelem(id1);
                }    
              }
            }
          }
        }
      }
      else
      { rules2=cons(rules2,r);
      }
    }
  }
  if(rules2.size()==0) yyerror("Wrong rule for "s+gid);
  rules1=cons(rules1,xrule(cons(symelem(id1)),gterm(snode("$1"s))));
  rules=rules1;
  reorder_body(gid,id1,rules2);
  new_rules=cons(new_rules,grmrule(id1,rules2));
}
void reorder_rules(List<Grule> grules)
{ for(auto r:grules)
  { match r {
    rule grmrule(id, body):
      reorder_body(id,id, body);
    } 
  }
}
bool check_all_gempty(List<Xrule> rules) 
{ bool res=true;
  for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      match a {
      rule gterm(t): res=false;
      rule gcode(cc): res=false;
      }
    }
  }  
  return res;
}
void split_rules(List<Xrule> rules);
void make_rep(int one, List<Xrule> &xl, Gelem &e)
{ 
  split_rules(xl);
  string id1(new_symbol());
  string id2(new_symbol());
  Gaction g1;
  Gaction g2;
  if(check_all_gempty(xl))
  { g1=gempty();
    g2=gempty();
  }
  else
  { if(one) g1=gterm(tnode("cons"s,cons("$1"s)));
    else g1=gempty();
    g2=gterm(tnode("cons"s,List<string>({"$1"s,"$2"s})));
  }
  new_rules=cons(new_rules,grmrule(id2,xl));
  new_rules=cons(new_rules,grmrule(id1,
           cons(cons(xrule(one?cons(symelem(id2)):nullptr,g1)),
           xrule(cons(cons(symelem(id1)),symelem(id2)),g2))));
  xl=nullptr; destroy(e); e=symelem(id1);
}
void split_rules(List<Xrule> rules)
{ for(auto r:rules)
  { match r {
    rule xrule(elist, a):
      for(auto &e:elist)
      { match e {
        rule varelem(xl):
          split_rules(xl);
          string id(new_symbol());
          new_rules=cons(new_rules,grmrule(id,xl));
          xl=nullptr; destroy(e); e=symelem(id);
        rule optelem(xl):
          split_rules(xl);
          string id(new_symbol());
          new_rules=cons(new_rules,grmrule(id,cons(xrule(nullptr,gempty()),xl)));
          xl=nullptr; destroy(e); e=symelem(id);
        rule repelem1(xl): 
          make_rep(1,xl,e);
        rule repelem0(xl): 
          make_rep(0,xl,e);
        }
      }
    }
  }
}
void split_rules(List<Grule> rules)
{ for(auto r:rules)
  { match r {
    rule grmrule(id, body):
      split_rules(body);
    } 
  }
}
string literal_to_re(const string &s)
{ string t=decode_string(s.substr(1,s.size()-2));
  string r="";
  static string meta="\\\'\"<>{}()*+.?[]/|$^ ";
  for(auto c:t)
  { if(c=='\n') r+="\\n";
    else if(c=='\t') r+="\\t";
    else if(meta.find(c)!=string::npos) { r+='\\'; r+=c; }
    else if((c&0xFF)>=0x7F) { 
      r+="\\x"s; 
      ostringstream v;
      v<<hex<<(c&0xFF);
      r+=v.str();
    }
    else
      r+=c;
  }
  return r;
}
void gen_altnames()
{
  for(auto &s:symbols)
  {
    if(s.first[0]=='\'')
    { s.second.altname=s.first;
      if(!empty_type(s.second.tip))
      { s.second.altname="\""s+encode_string(decode_string(s.first.substr(1,s.first.size()-2)),0)+"\""s;
        s.second.terminalnumber=++terminal_uid;
      }
    }
    else if(s.first[0]=='?')
    { s.second.altname="\""s+encode_string(s.first,0)+"\""s;
      s.second.terminalnumber=++terminal_uid;
    }
    else if(s.first[0]=='\"')
    { s.second.altname="\""s+encode_string(decode_string(s.first.substr(1,s.first.size()-2)),0)+"\""s;
      s.second.terminalnumber=++terminal_uid;
    }
    else
    { 
      string a=encode_symbol(s.first);
      while(symbol_names.find(a)!=symbol_names.end())
      { a="g_"s+to_string(++symbol_uid);
      }
      symbol_names.insert(a);
      s.second.altname=a;
    }
  }
}
void find_return_field(List<Code> code)
{ for(auto c:code)
  match c 
  { rule pcode(cc):
      find_return_field(cc);
    rule token(val):
      { string id=normalize_terminal(val);
        auto it=symbols.find(id);
        if(it==symbols.end())
          yyerror(id+" isn't used in rules");
        int rf=0;
        string tip=it->second.tip;
        if(!empty_type(tip))
        { if(union_fields.find(tip)!=union_fields.end())
            rf=union_fields[tip];
        }
        if(return_field!=0 && rf!=0 && return_field!=rf)
          yyerror("Return terminals with different types"s);
        if(rf!=0) return_field=rf;
      }
  }
}
void gen_code(ostream& fout, Term t, int limit)
{ match t {
    rule tnode(id, args):
    { bool flg=0;
      bool loc;
      if((loc=nodes.find(id)!=nodes.end()) || id=="cons"s)
        fout<<"ast::";
      fout<<id<<"(";
      for(auto a:args)
      { if(flg) fout<<",";
        gen_coderef(fout,a,0,limit);
        flg=1;
      }
      if(gen_mode>=1 && loc && locations_flag==2)
      { if(flg) fout<<",";
        if(gen_mode==2)
          fout<<"&@$";
        else
          fout<<"&yylloc";
      }
      fout<<")";
    }
    rule snode(str): 
      gen_coderef(fout,str,0,limit);
  }
}
void print_re(ostream& fout, string s)
{
  if(s.substr(0,2)=="R\""s)
  { 
    
    size_t p1=s.find('(');
    size_t p2=s.rfind(')');
    if(p1>=2 && s.size()-p2-2==p1-2 && 
       string(p1-2,s[2])==s.substr(2,p1-2) && string(p1-2,s[2])==s.substr(p2+1,p1-2))
    { s=s.substr(p1+1,p2-p1-1);
      for(auto c:s)
      { if(c==' ') fout<<"\\ ";
        else fout<<c;
      }
    }
    else
      fout<<s;
  }
  else
    fout<<s;
}
void gen_lexrules(ostream& fout, List<Lrule> rules)
{ for(auto r:rules)
  {
    match r {
    rule lexrule(sts, re, act):
      if(sts) {
        fout<<"<";
        bool flg=0;
        for(auto s:sts)
        { if(flg) fout<<",";
          fout<<s;
          flg=1;
        }
        fout<<">";
      }
      print_re(fout,re);
      fout<<"\t";
      match act {
      rule lterm(id,t):
         {
           fout<<"{";
           if(id)
           { string nid=normalize_terminal(id);
             auto it=symbols.find(nid);
             int rf=0;
             if(!empty_type(it->second.tip))
               rf=union_fields[it->second.tip];
             if(t)
             { 
               show_line(fout,t->yyloc.first.line-1,t->yyloc.first.column-(7+to_string(rf).size()+1));
               fout<<"yylval.f"<<to_string(rf)<<"_=";
               gen_mode=1;
               gen_code(fout,t,0);
               fout<<"; ";
             }
             else if(it->second.tip=="std::string"s || it->second.tip=="std::string?"s)
               fout<<" yylval.f"<<to_string(rf)<<"_=yytext; ";
             else if(it->second.tip=="char"s || it->second.tip=="char?"s)
               fout<<" yylval.f"<<to_string(rf)<<"_=yytext[0]; ";
             fout<<" return ";
             auto idt=symbols.find(nid);
             if(idt->second.terminalnumber>0)
               fout<<idt->second.terminalnumber;
             else 
               fout<<idt->second.altname;
           }
           else
             fout<<" return yyliteral(yytext)";
           fout<<"; }\n";
         }
      rule lskip(): fout<<";\n";
      rule lnext(): fout<<"|\n";
      rule lcode(code):
         return_field=0;
         find_return_field(code);
         gen_mode=1;
         fout<<"{";
         show_line(fout,@$.first.line-1,@$.first.column+1);
         gen_code(fout,code,0,0);
         fout<<"\t}\n";
      }
    }
  }
}
void create_lexfile(ostream& fout,const string &fn,List<Lrule> lrules)
{
  if(case_flag)
    fout<<"%option case-insensitive\n";
  if(inter_flag)
    fout<<"%option interactive\n";
  if(yywrap_flag==0)
    fout<<"%option noyywrap\n";
  fout<<"%option bison-bridge noline\n";
  fout<<"%top{\n"
        "#include \""<<fn<<".h\"\n";
  if(locations_flag!=0)
    fout<<"#define YY_USER_ACTION yysetloc();\n";
  if(locations_flag==1)
    fout<<"int yylineno;\n";
  fout<<"%}\n";
  fout<<R"___(
%class {
public:
  std::vector<std::string> filenames;
  int activefile;
%}
)___";
  fout<<R"___(
%init {
  filenames.push_back("");
  activefile=0;
%}
)___";
  if(locations_flag==2)
  fout<<R"___(
%class {
public: YYLTYPE yylloc;
  void yysetloc(){
    yylloc.first.line=lineno();
    yylloc.first.file=activefile;
    yylloc.first.column=short(columno()+1);
    yylloc.last.line=lineno();
    yylloc.last.file=activefile;
    yylloc.last.column=short(columno()+size());
  }
%}
)___";
  else if(locations_flag==1)
  fout<<R"___(
%class {
  void yysetloc(){
#undef yylineno
    yylineno=lineno();
  }
%}
)___";
  gen_code(fout,lexcode,0,0);
  if(lex_states.size()>0)
  {
    fout<<"%x";
    for(auto s:lex_states)
      fout<<" "<<s;
    fout<<"\n";
  }
  for(auto &ld:lexdefs) {
    fout<<ld.id<<"\t";
    print_re(fout,ld.re);
    fout<<"\n";
  }
  fout<<"%%\n";
  if(locations_flag==1)
  {
    fout<<"%{\n";
    if(lex_states.size()>0)
      fout<<"default:";
    if(locations_flag==1)
      fout<<"\tyyclear_attr(yylval);\n";
    fout<<"%}\n";
  }
  if(literal_flag)
  { 
    for(auto s:symbols)
    { if(isliteral(s.first))
      {
        fout<<literal_to_re(s.first)<<"\t";
        int rf=0;
        if(!empty_type(s.second.tip))
          rf=union_fields[s.second.tip];
        if(s.second.tip=="std::string"s || s.second.tip=="std::string?"s)
          fout<<"yylval.f"<<to_string(rf)<<"_=yytext; ";
        else if(s.second.tip=="char"s || s.second.tip=="char?"s)
          fout<<"yylval.f"<<to_string(rf)<<"_=yytext[0]; ";
        fout<<"return ";
        if(s.second.terminalnumber>0)
          fout<<s.second.terminalnumber;
        else 
          fout<<s.second.altname;
        fout<<";\n";
      }
    }
  }
  gen_lexrules(fout,lrules);
  if(lexdefault_flag!=1)
  {
    if(lex_states.size()>0)
    { fout<<"<INITIAL";
      for(auto s:lex_states)
        fout<<","<<s;
      fout<<">";
    }
    fout<<".|\\n\t";
    if(lexdefault_flag==0)
      fout<<"yyerror(\"No rules for char \"+std::to_string(yytext[0]&0xFF));\n";
    else if(lexdefault_flag==2)
      fout<<";\n";
    else
      fout<<"return yyliteral(yytext);\n";
  }
  fout<<"%%\n";
  if(locations_flag==2)
    fout<<R"___(
int yylex(YYSTYPE* lvalp, YYLTYPE* llocp, void* scanner) {
  yyscanner_t* scanp=reinterpret_cast<yyscanner_t*>(scanner);
  yyclear_attr(*lvalp);
  int t=scanp->yylex(*lvalp);
  *llocp=scanp->yylloc;
  return t;
}
)___";
  fout<<R"___(
const char *yylex_filename(void* scanner, int i)
{ yyscanner_t* scanp=reinterpret_cast<yyscanner_t*>(scanner);
  if(i>=scanp->filenames.size()) return "";
  if(i<0) i=scanp->activefile;
  return scanp->filenames[i].c_str();
}
void yylex_init(yyscan_t *scanner, FILE *f, const std::string& n)
{ yyscanner_t* scanp=new yyscanner_t;
  *scanner = static_cast<yyscan_t>(scanp);
  scanp->in(f);
  scanp->filenames[0]=n;
}
void yylex_init(yyscan_t *scanner, std::istream &s, const std::string& n)
{ yyscanner_t* scanp=new yyscanner_t;
  *scanner = static_cast<yyscan_t>(scanp);
  scanp->in(s);
  scanp->filenames[0]=n;
}
)___";
}
bool need_destroy(const string &t)
{ return t=="std::string?"s || t=="std::string"s || !(t.back()=='?' || is_builtin_type(t));
}
void create_grmfile(ostream& fout,const string &fn, List<Grule> rules)
{
  if(locations_flag==2)
    fout<<"%locations\n";
  fout<<"%define parse.error verbose\n"
        "%define api.pure full\n"
        "%param { void *scanner }\n"
        "%no-lines\n";
  if(expect_flag>=0)
    fout<<"%expect"<<expect_flag<<"\n";
  fout<<"%{\n";
  fout<<"#include \""<<fn<<".h\"\n";
  fout<<R"___(
#define YYLLOC_DEFAULT(Current, Rhs, N)                        \
    do {                                                       \
      if (N)                                                   \
        {                                                      \
          (Current).first   = YYRHSLOC (Rhs, 1).first;         \
          (Current).last  = YYRHSLOC (Rhs, N).last;            \
        }                                                      \
      else                                                     \
        {                                                      \
          (Current).first = (Current).last = YYRHSLOC (Rhs, 0).last; \
        }                                                      \
      yyclear_attr(yyval);                                     \
    } while (0)
)___";
  fout<<"%}\n";
  gen_code(fout,grmcode,0,0);
  for(auto s:symbols)
  { if(isterminal(s.first))
    {
      if(s.second.terminalnumber)
      { fout<<"%token ";
        if(!empty_type(s.second.tip))
          fout<<"<f"<<union_fields[s.second.tip]<<"_> ";
        fout<<"T_"<<s.second.terminalnumber<<" "<<s.second.terminalnumber<<" "<<s.second.altname<<"\n";
      }
    }
    else if(!empty_type(s.second.tip))
    { fout<<"%type <f"<<union_fields[s.second.tip]<<"_> "<<s.second.altname<<"\n";
    }
  }
  string root_id;
  match rules[0] {
    rule grmrule(id,body):
      if(!empty_type(symbols[id].tip)) {
        string tip=symbols[id].tip;
        root_id=id;
        root_tip=tip;
        if(tip.back()=='?') tip.pop_back();
        fout<<"%destructor { ";
        if(astprint_flag)
          fout<<"if(yydebug_flag==2) ast::astprint(cout,$$); else ";
        fout<<"YYINTERPRET($$,scanner); ";
        if(need_destroy(tip))
           fout<<"ast::destroy($$); ";
        fout<<"} "<<symbols[id].altname<<"\n";
      }
      else
        root_tip="";
  }
  for(auto &uf:union_fields)
  { string t=uf.first;
    if(root_tip!=""s && t==root_tip && need_destroy(t))
    { vector<string> root_syms;
      for(auto &sym:symbols)
      { if(sym.second.tip==root_tip && sym.first!=root_id)
          root_syms.push_back(sym.second.altname);
      }
      if(root_syms.size()>0)
      { 
        fout<<"%destructor { ast::destroy($$); }";
        for(auto &sym:root_syms)
          fout<<" "<<sym;
        fout<<"\n";
      }
    }
    else if(need_destroy(t))
    { 
      fout<<"%destructor { ast::destroy($$); } <f"<<uf.second<<"_>\n";
    }
  }
  fout<<"%%\n";
  for(auto r:rules)
  {
    match r {
    rule grmrule(id, body):
      fout<<symbols[id].altname<<"\t:";
      int flg=0;
      for(auto x : body)
      { if(flg) fout<<"\t|";
        match x {
        rule xrule(elist, act):
          {
            for(auto &e:elist)
            { match e {
              rule trmelem(str): 
                auto &sym=symbols[normalize_terminal(str)];
                if(sym.terminalnumber>0)
                  fout<<" T_"<<sym.terminalnumber<<" ";
                else
                  fout<<" "<<sym.altname;
              rule symelem(str): 
                fout<<" "<<symbols[str].altname;
              }
            }
            match act {
              rule gempty(): 
                if(locations_flag!=2)
                  fout<<"\t{ yyclear_attr(yyval); }\n";
                else
                  fout<<"\n";
              rule gcode(cc):
                { fout<<"\t{";
                  if(locations_flag!=2)
                    fout<<" yyclear_attr(yyval);";
                  gen_mode=2;
                  gen_code_line(fout,cc,0,elist.size());
                  fout<<" }\n";
                }
              rule gterm(t):
                { fout<<"\t{";
                  if(locations_flag!=2)
                    fout<<" yyclear_attr(yyval);";
                  show_line(fout,t->yyloc.first.line,t->yyloc.first.column-2);
                  fout<<"$$=";
                  gen_mode=2;
                  gen_code(fout,t,elist.size());
                  fout<<"; }\n";
                }
            }
          }
        }
        flg=1;
      }
      fout<<"\t;\n";
    }
  }
  fout<<"%%\n";
}
string to_field_type(const string &tip)
{  if(tip.back()=='?')
      return "ast::Value<"s+tip.substr(0,tip.size()-1)+">"s;
   else if(is_big_builtin_type(tip))
      return "ast::Value<"s+tip+">"s;
   else
      return tip;
}
void create_hfile(ostream& fout,const string &fn)
{ 
  string ufn=fn;
  for(auto &c:ufn)
    c=toupper(c);
  fout<<"#ifndef "<<ufn<<"_H\n";
  fout<<"#define "<<ufn<<"_H 1\n";
if(using_list.size()>0)
{
  for(auto &ul:using_list)
    fout<<"#include \""<<ul<<".h\""<<"\n";
}
else
{
  fout<<R"___(
#ifndef ASTTYPES_H
#define ASTTYPES_H 1
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <exception>
#include <utility>
#include <vector>
#include <initializer_list>
)___";
if(locations_flag==2)
fout<<R"___(
struct YYPTYPE {
  int line;
  short file, column;
};
struct YYLTYPE {
  YYPTYPE first,last;
  YYLTYPE(int fl=0,int fc=0,int ll=0,int lc=0, int ff=0){ 
     first.line=fl; first.column=fc;
     last.line=ll; last.column=lc;
     first.file=last.file=ff;
  }
};
#define YYLTYPE_IS_DECLARED 1
#define YYLTYPE_IS_TRIVIAL 1
)___";
fout<<R"___(
namespace ast {

template <typename T> inline void destroy(T& p) { }
template <typename T> inline void destroy(T*& p) { if(p) delete p; p=nullptr; }
)___";
if(usestring_flag || usevalue_flag)
fout<<R"___(
template <typename T>
class Value {
  int _assigned;
  T _value;
  void check() const { if(!_assigned) throw std::logic_error("value isn't assigned"); }
public:
  Value()=default;
  explicit Value(const T& v){ _assigned=1; _value=v; }
  Value(const Value<T>& v)=default;
  Value(std::nullptr_t) { _assigned=0; }
  operator T() const { check(); return _value; }
  operator bool() const{ return _assigned!=0; }
  bool operator!() const{ return !_assigned; }
  Value<T> operator~() const{ check(); return Value<T>(~_value); }
  Value<T> operator-() const{ check(); return Value<T>(-_value); }
  Value<T> &operator=(const T& v) { _assigned=1; _value=v; }
  Value<T> &operator=(std::nullptr_t) { _assigned=0; }
  Value<T> &operator=(const Value<T>& v)=default;
  Value<T> &operator+=(const T& v) { check(); _value+=v; return *this; }
  Value<T> &operator-=(const T& v) { check(); _value-=v; return *this; }
  Value<T> &operator*=(const T& v) { check(); _value*=v; return *this; }
  Value<T> &operator/=(const T& v) { check(); _value/=v; return *this; }
  Value<T> &operator%=(const T& v) { check(); _value%=v; return *this; }
  Value<T> &operator<<=(const T& v) { check(); _value<<=v; return *this; }
  Value<T> &operator>>=(const T& v) { check(); _value>>=v; return *this; }
  Value<T> &operator&=(const T& v) { check(); _value&=v; return *this; }
  Value<T> &operator|=(const T& v) { check(); _value|=v; return *this; }
  Value<T> &operator^=(const T& v) { check(); _value^=v; return *this; }
  Value<T> &operator++() { check(); ++_value; return *this; }
  Value<T> &operator--() { check(); --_value; return *this; }
  T *operator&() { _assigned=1; return &_value; }
  friend inline std::istream &operator>>(std::istream&s, Value<T> &v) { v._assigned=1; return s>>v._value; }
  friend inline std::ostream &operator<<(std::ostream&s, const Value<T> &v) { return s<<T(v); }
};
template <typename T>
inline T operator+(const Value<T>& v1, const Value<T>& v2) { return T(v1)+T(v2); }
template <typename T>
inline Value<T> operator-(Value<T> v1, const Value<T>& v2) { return v1-=v2; }
template <typename T>
inline Value<T> operator*(Value<T> v1, const Value<T>& v2) { return v1*=v2; }
template <typename T>
inline Value<T> operator/(Value<T> v1, const Value<T>& v2) { return v1/=v2; }
template <typename T>
inline Value<T> operator%(Value<T> v1, const Value<T>& v2) { return v1%=v2; }
template <typename T>
inline Value<T> operator<<(Value<T> v1, const Value<T>& v2) { return v1<<=v2; }
template <typename T>
inline Value<T> operator>>(Value<T> v1, const Value<T>& v2) { return v1>>=v2; }
template <typename T>
inline Value<T> operator&(Value<T> v1, const Value<T>& v2) { return v1&=v2; }
template <typename T>
inline Value<T> operator|(Value<T> v1, const Value<T>& v2) { return v1|=v2; }
template <typename T>
inline Value<T> operator^(Value<T> v1, const Value<T>& v2) { return v1^=v2; }
template <typename T>
bool operator==(const Value<T> &v1, const Value<T>& v2) {
   if(!v1 && !v2) return 1;
   if(!v1 || !v2) return 0;
   return  T(v1)==T(v2); 
}
template <typename T>
bool operator<(const Value<T> &v1, const Value<T>& v2) { 
  if(!v1 && !v2) return 0;
  if(!v1) return 1;
  if(!v2) return 0;
  return T(v1)<T(v2); 
}
template <typename T>
inline bool operator!=(const Value<T> &v1, const Value<T>& v2) { return !(v1==v2); }
template <typename T>
inline bool operator>(const Value<T> &v1, const Value<T>& v2) { return v2<v1; }
template <typename T>
inline bool operator<=(const Value<T> &v1, const Value<T>& v2) { return !(v2<v1); }
template <typename T>
inline bool operator>=(const Value<T> &v1, const Value<T>& v2) { return !(v1<v2); }
template <typename T>
Value<T> &operator++(Value<T> &v, int)
{ Value<T> v2(v);
  ++v;
  return v2;
}
template <typename T>
Value<T> &operator--(Value<T> &v, int)
{ Value<T> v2(v);
  --v;
  return v2;
}
)___";
if(usestring_flag)
fout<<R"___(
template <>
class Value<std::string> {
  size_t _len;
  char *_str;
  void check() const { if(!_str) throw std::logic_error("value isn't assigned"); }
  void del_ptr() { if(_str) free(_str); _str=nullptr; _len=0; }
  void new_ptr(const char *s, size_t l) { _len=l; if(s) _str=strdup(s); else _str=nullptr; }
public:
  Value()=default;
  explicit Value(const char *s) { new_ptr(s,strlen(s)); }
  Value(const char *s, int l) { new_ptr(s,l); }
  explicit Value(const std::string &s) { new_ptr(s.c_str(),s.length()); }
  Value(std::nullptr_t) { new_ptr(nullptr,0); }
  operator std::string() const { check(); return _str; }
  operator bool() const{ return _str!=nullptr; }
  bool operator!() const{ return !_str; }
  const char *c_str() const { check(); return _str; }
  size_t size() const { check(); return _len; }
  size_t length() const { check(); return _len; }
  char operator[](size_t i) const { check(); return _str[i]; }
  char at(size_t i) const { check(); if(i>=_len) throw std::out_of_range("index out of range"); return _str[i]; }
  std::string substr(size_t i, size_t n=std::string::npos) const { check(); return ((std::string)_str).substr(i,n); }
  Value<std::string> &operator=(const std::string& s) { del_ptr(); new_ptr(s.c_str(),s.length()); return *this; }
  Value<std::string> &operator=(const char *s) { del_ptr(); new_ptr(s,strlen(s)); return *this; }
  Value<std::string> &operator=(std::nullptr_t) { del_ptr(); new_ptr(nullptr,0); return *this; }
  Value<std::string> &operator=(const Value<std::string>& v)=default;
  Value<std::string> &operator+=(const std::string& s) { check(); (*this)=(std::string)_str+s; return *this; }
  Value<std::string> &operator+=(const char *s) { check(); (*this)=(std::string)_str+(std::string)s; return *this; }
  Value<std::string> &operator+=(char c) { check(); (*this)=(std::string)_str+std::string(1,c); return *this; }
  friend inline std::istream &operator>>(std::istream&s, Value<std::string> &v) { std::string x; s>>x; v=x; return s; }
  friend inline std::ostream &operator<<(std::ostream&s, const Value<std::string> &v) { v.check(); return s<<v._str; }
  friend inline void destroy(Value<std::string> &v) { v.del_ptr(); }
};
template <typename T>
inline T operator+(const T &v1, const Value<T>& v2) { return v1+T(v2); }
template <typename T>
inline T operator+(const Value<T>& v1, const T& v2) { return T(v1)+v2; }
template <typename T>
bool operator==(const T &v1, const Value<T>& v2) { 
  if(!v2) return 0;
  return v1==T(v2); 
}
template <typename T>
bool operator==(const Value<T> &v1, const T& v2) {
  if(!v1) return 0;
  return T(v1)==v2; 
}
template <typename T>
bool operator<(const T &v1, const Value<T>& v2) { 
  if(!v2) return 0;
  return v1<T(v2); 
}
template <typename T>
bool operator<(const Value<T> &v1, const T& v2) { 
  if(!v1) return 1;
  return T(v1)<v2; 
}
template <typename T>
inline bool operator!=(const T &v1, const Value<T>& v2) { return !(v1==v2); }
template <typename T>
inline bool operator!=(const Value<T> &v1, const T& v2) { return !(v1==v2); }
template <typename T>
inline bool operator>(const T &v1, const Value<T>& v2) { return v2<v1; }
template <typename T>
inline bool operator>(const Value<T> &v1, const T& v2) { return v2<v1; }
template <typename T>
inline bool operator<=(const T &v1, const Value<T>& v2) { return !(v2<v1); }
template <typename T>
inline bool operator<=(const Value<T> &v1, const T& v2) { return !(v2<v1); }
template <typename T>
inline bool operator>=(const T &v1, const Value<T>& v2) { return !(v1<v2); }
template <typename T>
inline bool operator>=(const Value<T> &v1, const T& v2) { return !(v1<v2); }
)___";
if(uselist_flag)
fout<<R"___(
template <typename T> class List;
template <typename T> List<T> cons(const T& p);
template <typename T> List<T> cons(List<T> l, const T& p);
template <typename T> List<T> cons(const T& p, List<T> l);
)___";
if(uselist_flag && (usestring_flag || usevalue_flag))
fout<<R"___(
template <typename T> List<T> cons(const Value<T> &p);
template <typename T> List<T> cons(List<T> l, const Value<T> &p);
template <typename T> List<T> cons(const Value<T> & p, List<T> l);
)___";
if(uselist_flag)
fout<<R"___(
template <typename T> List<T> cons(List<T> l1, List<T> l2);
template <typename T> List<T> begin(List<T> l);
template <typename T> List<T> end(List<T> l);
template <typename T> bool operator==(const List<T> &l, const List<T> &r);
template <typename T> List<T> &operator++(List<T> &l);
template <typename T> void destroy(List<T> &l);

template <typename T>
class List {
  struct Node {
    T head;
    Node *tail;
    Node(const T& h, Node* t):head(h),tail(t){}
  };
  Node *first;
  Node *last;
  size_t _size;
  void add_last(Node *n) { 
    n->tail=nullptr;
    ++_size;  
    if(first==nullptr) first=last=n;
    else { last->tail=n; last=n; }
  }
  void add_first(Node *n) { 
    n->tail=first;
    ++_size;
    if(first==nullptr) first=last=n; 
    else first=n;
  }
public:
  List()=default;
  List(std::nullptr_t) { first=last=nullptr; _size=0; }
  List(std::initializer_list<T> v);
  T &operator*() { return first->head; }
  T *operator->() { return &(first->head); }
  T &operator[](size_t i);
  size_t size() const { return _size; }
  template <typename UnaryPredicate> List<T> split(UnaryPredicate pred);
  List<T>& operator=(std::nullptr_t) { first=nullptr; last=nullptr; return *this; }
  
  friend List<T> cons<T>(const T& p);
  friend List<T> cons<T>(List<T> l, const T& p);
  friend List<T> cons<T>(const T& p, List<T> l);
)___";
if(uselist_flag && (usestring_flag || usevalue_flag))
fout<<R"___(
  friend List<T> cons<T>(const Value<T> &p);
  friend List<T> cons<T>(List<T> l, const Value<T> &p);
  friend List<T> cons<T>(const Value<T> & p, List<T> l);
)___";
if(uselist_flag)
fout<<R"___(
  template <typename Z> friend List<Z*> cons(Z *p);
  template <typename Z> friend List<Z*> cons(List<Z*> l, Z *p);
  template <typename Z> friend List<Z*> cons(Z* p, List<Z*> l);
  
  friend List<T> cons<T>(List<T> l1, List<T> l2);
  friend List<T> begin<T>(List<T> l);
  friend List<T> end<T>(List<T> l);
  friend void destroy<T>(List<T> &l);
  friend bool operator==<T>(const List<T> &l, const List<T> &r);
  friend List<T> &operator++ <T>(List<T> &l);
  operator bool() const { return first!=nullptr; }
  bool operator!() const { return first==nullptr; }
};
template <typename T> 
void destroy(List<T> &l) {
  List<T> t,r=begin(l),e=end(l); 
  while(r!=e)
  { t=r; 
    ++r;
    destroy(t.first->head);
    delete t.first;
  }
  l=nullptr;
}
template <typename T> 
  template <typename UnaryPredicate>
List<T> List<T>::split(UnaryPredicate pred)
{ List<T> r1=nullptr,r2=nullptr;
  List<T> t,r=begin(*this),e=end(*this); 
  while(r!=e)
  { t=r;
    ++r;
    if(pred(t.first->head))
      r1.add_last(t.first);
    else
      r2.add_last(t.first);
  }
  *this=r2;
  return r1;
}
template <typename T>
List<T>::List(std::initializer_list<T> v)
{ first=nullptr;
  last=nullptr;
  _size=v.size();
  for(auto &x:v)
  { Node *t=new typename List<T>::Node(x,nullptr);
    if(!first) first=last=t;
    else 
    { last->tail=t;
      last=t;
    }
  }
}
template <typename T>
T &List<T>::operator[](size_t i)
{ if(i>=_size) throw std::out_of_range(std::string("index ")+std::to_string(i)+std::string(" is out List's size ")+std::to_string(_size));
  if(i==0) return first->head;
  if(i==_size-1) return last->head;
  Node *t=first;
  while(i>0) { t=t->tail; --i; }
  return t->head;
}
template <typename T>
List<T> cons(const T& p)
{ List<T> r; 
  r.first=r.last=new typename List<T>::Node(p,nullptr);
  r._size=1;
  return r;
}
template <typename T>
List<T> cons(List<T> l, const T& p)
{ 
  if(l.first==nullptr) return cons(p);
  List<T> r;
  r.first=l.first;
  l.last->tail=new typename List<T>::Node(p,nullptr);
  r.last=l.last->tail;
  r._size=l._size+1;
  return r;
}
template <typename T>
List<T> cons(const T& p, List<T> l)
{
  if(l.first==nullptr) return cons(p);
  List<T> r;
  r.first=new typename List<T>::Node(p,l.first);
  r.last=l.last;
  r._size=l._size+1;
  return r;
}
template <typename T>
inline List<T> cons(List<T> l)
{
  return l;
}
)___";
if(uselist_flag && (usestring_flag || usevalue_flag))
fout<<R"___(
template <typename T>
List<T> cons(const Value<T> & p)
{ 
  if(!p) return List<T>(nullptr);
  return cons(static_cast<T>(p));
}
template <typename T>
List<T> cons(List<T> l, const Value<T> &p)
{ 
  if(!p) return l;
  return cons(l,static_cast<T>(p));
}
template <typename T>
List<T> cons(const Value<T> &p, List<T> l)
{
  if(!p) return l;
  return cons(static_cast<T>(p),l);
}
)___";
if(uselist_flag)
fout<<R"___(
template <typename T>
List<T *> cons(T* p)
{ List<T*> r(nullptr);
  if(!p) return r;
  r.first=r.last=new typename List<T*>::Node(p,nullptr);
  r._size=1;
  return r;
}
template <typename T>
List<T*> cons(List<T*> l, T *p)
{ 
  if(!p) return l;
  if(l.first==nullptr) return cons(p);
  List<T*> r;
  r.first=l.first;
  r.last=l.last->tail=new typename List<T*>::Node(p,nullptr);
  r._size=l._size+1;
  return r;
}
template <typename T>
List<T*> cons(T *p, List<T*> l)
{
  if(!p) return l;
  if(l.first==nullptr) return cons(p);
  List<T*> r;
  r.first=new typename List<T*>::Node(p,l.first);
  r.last=l.last;
  r._size=l._size+1;
  return r;
}

template <typename T>
List<T> cons(List<T> l1, List<T> l2)
{ 
  if(l1.first==nullptr) return l2;
  if(l2.first==nullptr) return l1;
  List<T> r;
  r.first=l1.first;
  l1.last->tail=l2.first;
  r.last=l2.last;
  r._size=l1._size+l2._size;
  return r;
}
template <typename T>
inline List<T> begin(List<T> l)
{ return l;
}
template <typename T>
inline List<T> end(List<T> l)
{ l.first=0;
  l._size=0;
  return l;
}
template <typename T>
inline bool operator==(const List<T> &l, const List<T> &r)
{ return l.first==r.first && l.last==r.last;
}
template <typename T>
inline bool operator!=(const List<T> &l, const List<T> &r)
{ return !(l==r);
}
template <typename T>
inline List<T> &operator++(List<T> &l)
{ if(l.first==l.last) l.first=nullptr;
  else l.first=l.first->tail;
  --l._size;
  return l;
}
template <typename T>
inline List<T> operator++(List<T> &l, int)
{ List<T> r(l);
  ++l;
  return r;
}
)___";
fout<<R"___(
#ifndef AST_BASE_DOMAIN
#define AST_BASE_DOMAIN 1
struct _domain {
)___";
if(locations_flag==2)
fout<<R"___(
  YYLTYPE yyloc;
  _domain(const YYLTYPE *_loc) { if(_loc) yyloc=*_loc; else memset(&yyloc,0,sizeof(yyloc)); }
)___";
fout<<R"___(
  virtual ~_domain(){}
};
#endif
}
#endif
)___";
}
  if(domains.size()>0)
  {
  fout<<"namespace ast {\n";
  for(auto &d:domains)
  { 
    if(visitor_flag==2)
      fout<<"struct "<<d.first<<"_visitor;\n";
    fout<<"struct "<<d.first<<"_domain : _domain {\n";
    if(locations_flag==2)
      fout<<"\t"<<d.first<<"_domain(const YYLTYPE *_loc):_domain(_loc) {}\n";
    if(visitor_flag==2)
      fout<<"\tvirtual void accept("<<d.first<<"_visitor*, void*)=0;\n";
    fout<<"};\n";
    fout<<"typedef "<<d.first<<"_domain *"<<d.first<<";\n";
    if(astprint_flag)
      fout<<"int astprint(std::ostream&, "<<d.first<<", int=0, const char* =nullptr);\n";
  }
  for(auto &n:nodes)
  { 
    fout<<"struct "<<n.first<<"_node : "<<n.second.types[0]<<"_domain {\n";
    for(int j=1;j<n.second.types.size();++j)
    {
      fout<<"\t"<<type_mark(n.second.types[j],0)<<" f"<<j<<"_;\n";
    }
    fout<<"\t"<<n.first<<"_node(";
    if(n.second.types.size()>1)
    {
      for(int j=1;j<n.second.types.size();++j) 
      {
        fout<<type_mark(n.second.types[j],1)<<" a"<<j;
        if(j<n.second.types.size()-1)
          fout<<", ";
        else if(locations_flag==2)
          fout<<", const YYLTYPE *_loc=nullptr):"<<n.second.types[0]<<"_domain(_loc), ";
        else
          fout<<"):";
      }
      for(int j=1;j<n.second.types.size();++j)
      {
        fout<<"f"<<j<<"_(a"<<j<<")";
        if(j<n.second.types.size()-1)
          fout<<", ";
      }
    }
    else if(locations_flag==2)
      fout<<"const YYLTYPE *_loc=nullptr):"<<n.second.types[0]<<"_domain(_loc) ";
    else
      fout<<")";
    fout<<"{}\n";
    int kd=0;
    for(int j=1;j<n.second.types.size();++j)
    { string t=n.second.types[j];
      if(t=="std::string"s) ;
      else if(need_destroy(t))
        ++kd;
    }
    if(kd>0)
    {
      fout<<"\t~"<<n.first<<"_node() {\n";
      for(int j=1;j<n.second.types.size();++j)
      { string t=n.second.types[j];
        if(t=="std::string"s) ;
        else if(need_destroy(t))
        {
          fout<<"\t  destroy(f"<<j<<"_);\n";
        }
      }
      fout<<"\t}\n";
    }
    if(visitor_flag==2)
      fout<<"\tvoid accept("<<n.second.types[0]<<"_visitor*, void*);\n";
    fout<<"};\n";
  }
  for(auto &n:nodes)
  { 
    fout<<"inline "<<n.second.types[0]<<" "<<n.first<<"(";
     
    for(int j=1;j<n.second.types.size();++j) 
    {
      fout<<type_mark(n.second.types[j],1)<<" a"<<j;
      if(j<n.second.types.size()-1)
        fout<<", ";
    }
    if(locations_flag==2)
    { if(n.second.types.size()>1)
        fout<<", ";
      fout<<"const YYLTYPE *_loc=nullptr";
    }
    fout<<") {\n";
    fout<<"\treturn new "<<n.first<<"_node(";
    for(int j=1;j<n.second.types.size();++j) 
    {
      fout<<"a"<<j;
      if(j<n.second.types.size()-1)
        fout<<", ";
    }
    if(locations_flag==2)
    { if(n.second.types.size()>1)
        fout<<", ";
      fout<<"_loc";
    }
    fout<<");\n"
        <<"}\n";
  }
  if(visitor_flag==2)
  {
    for(auto &d:domains)
    { 
      fout<<"struct "<<d.first<<"_visitor {\n\tvirtual ~"<<d.first<<"_visitor(){}\n";
      for(auto &n:d.second.nodes)
      { fout<<"\tvirtual void visit("<<n<<"_node*, void*) {}\n";
      }
      fout<<"};\n";
      fout<<"template <typename T> struct "<<d.first<<"_Tvisitor: "<<d.first<<"_visitor {\n";
      fout<<"\tT operator()("<<d.first<<" v){ T r; if(v) v->accept(this,&r); return r; }\n";
      for(auto &n:d.second.nodes)
      { fout<<"\tvirtual T visit("<<n<<"_node*) { return T(); }\n";
        fout<<"\tvoid visit("<<n<<"_node* n,void* r) { *reinterpret_cast<T*>(r)=visit(n); }\n";
      }
      fout<<"};\n";
      fout<<"template <> struct "<<d.first<<"_Tvisitor<void>: "<<d.first<<"_visitor {\n";
      fout<<"\tvoid operator()("<<d.first<<" v){ if(v) v->accept(this,nullptr); }\n";
      for(auto &n:d.second.nodes)
      { fout<<"\tvirtual void visit("<<n<<"_node*) {}\n";
        fout<<"\tvoid visit("<<n<<"_node* n,void* r) { visit(n); }\n";
      }
      fout<<"};\n";
    }
    for(auto &n:nodes)
    { 
      fout<<
        "inline void "<<n.first<<"_node::accept("<<n.second.types[0]<<"_visitor* v, void* r) {\n"
        "\tv->visit(this, r);\n}\n";
    }
  }
  fout<<"}\n";
  }
  fout<<"using namespace ast;\n";
if(using_list.size()==0 && ast_flag==0)
{
  if(locations_flag==1)
    fout<<"extern int yylineno;\n";
  fout<<"int yyliteral(const std::string&);\n"
        "int yywrap();\n"
        "int yyparse(void*);\n";
  if(main_flag)
    fout<<"extern const char* yyinputfile;\n"
          "extern int yydebug_flag;\n";
  if(union_fields.size()>0)
  { fout<<"union YYSTYPE {\n";
    for(auto &f:union_fields)
      fout<<"  "<<to_field_type(f.first)<<" f"<<f.second<<"_;\n";
    fout<<"};\n";
  }
  else
    fout<<"typedef int YYSTYPE;\n";
  fout<<"inline void yyclear_attr(YYSTYPE&v) { memset(&v,0,sizeof(v)); }\n"
          "#define YYSTYPE_IS_TRIVIAL 1\n"
          "#define YYSTYPE_IS_DECLARED 1\n";
  fout<<"void yylex_destroy(void*);\n"
        "const char* yylex_filename(void*, int=-1);\n"
        "void yylex_init(void**);\n"
        "void yylex_init(void**, FILE*, const std::string&);\n"
        "void yylex_init(void**, std::istream &, const std::string&);\n";
  if(locations_flag==2)
    fout<<"int yylex(YYSTYPE*, YYLTYPE*, void*);\n";
  else
    fout<<"int yylex(YYSTYPE*, void*);\n";
  if(lexprint_flag)
    fout<<"void lexprint(std::ostream&, int, YYSTYPE&);\n";
}
if(using_list.size()==0)
{
  fout<<"void yyerror(const std::string &);\n";
  if(locations_flag==2)
    fout<<"void yyerror(YYLTYPE*, void*, const char*);\n";
  else
    fout<<"void yyerror(void*, const char*);\n";
}
if(yyinterpret_flag && root_tip!="") {
  fout<<"void yyinterpret("<<type_mark(root_tip,1)<<");\n";
  fout<<"#define YYINTERPRET(ast,scanner) yyinterpret(ast)\n";
}
else
  fout<<"#define YYINTERPRET(ast,scanner)\n";
gen_mode=0;
gen_code_line(fout,hcode,0,0);

if((astprint_flag || lexprint_flag) && using_list.size()==0)
{
    fout<<R"___(
namespace ast {
#ifndef ASTPRINT_BUILTIN
#define ASTPRINT_BUILTIN 1
static void print_char(std::ostream &s, char v)
{ if(v=='\n') s<<"\\n";
  else if(v=='\'' || v=='\\' || v=='\"') s<<'\\'<<v;
  else s<<v;
}
static void print_indent(std::ostream &s, int i)
{ s<<'\n';
  if(i) { s.width(i); s<<' '; }
}
static int astprint(std::ostream &s, char v, int=0, const char *p=nullptr)
{ s<<"'";
  print_char(s,v);
  s<<"'";
  if(p) s<<p;
  return 0;
}
static int astprint(std::ostream &s, const std::string &v, int=0, const char *p=nullptr)
{ s<<'\"';
  for(auto x:v) print_char(s,x);
  s<<'\"';
  if(p) s<<p;
  return 0;
}
template <typename T> 
inline int astprint(std::ostream &s, T v, int=0, const char *p=nullptr)
{ s<<v; 
  if(p) s<<p;
  return 0;
}
#endif
)___";
if(usevalue_flag || usestring_flag)
fout<<R"___(
template <typename T>
int astprint(std::ostream &s, Value<T> v, int=0, const char *p=nullptr)
{ if(!v) s<<"nullptr";
  else astprint(s,T(v));
  if(p) s<<p;
  return 0;
}
)___";
if(uselist_flag)
fout<<R"___(
template <typename T>
int astprint(std::ostream &s, List<T> v, int i=0, const char *p=nullptr)
{ bool fl=0, r=0;
  s<<"[";
  for(auto x:v)
  {
    if(fl) s<<",";
    r+=astprint(s,x,i+2);
    fl=1;
  }
  if(r) print_indent(s,i);
  s<<"]";
  if(p) s<<p;
  return r;
}
)___";
fout<<"}\n";
}
  fout<<"#endif\n";
}
void create_cppfile(ostream& fout,const string &fn, List<Code> code)
{
  fout<<"#include \""<<fn<<".h\"\n";
  gen_mode=0;
  gen_code_line(fout,code,0,0);
  fout<<"\n";
  fout<<vout.str();
  vout.clear();
  fout<<"\n";
  if(using_list.size()==0 && ast_flag==0)
  {
    unsigned cset[8]={0};
    fout<<"#include <map>\nstatic std::map<std::string,int> yyliterals{\n";
    int flg=0;
    for(auto &s:symbols)
    { if(isliteral(s.first))
      { string t=decode_string(s.first.substr(1,s.first.size()-2));
        if(s.second.terminalnumber>0)
        { if(flg) fout<<",\n";
          fout<<"\t{\""<<encode_string(t,0)<<"\","<<s.second.terminalnumber<<"}";
          flg=1;
        }
        else
        { int c=t[0]&0xFF;
          cset[c>>5]|=1<<(c&31);
        }
      }
    }
    fout<<"};\n";
    fout<<"static unsigned yyliteral1[8]={";
    for(int i=0;i<8;++i) {
      fout<<cset[i]<<"u";
      if(i<7) fout<<",";
    }
    fout<<"};\n";
    fout<<"int yyliteral(const std::string&s) {\n"
        "  if(s.length()==0) return 0;\n"
        "  if(s.length()==1)\n"
        "  { int c=s[0]&0xFF;\n"
        "    if(yyliteral1[c>>5]&(1<<(c&31))) return c; else return 1;\n"
        "  }\n"
        "  auto it=yyliterals.find(s);\n"
        "  if(it==yyliterals.end()) return 1;\n"
        "  return it->second;\n"
        "}\n";
  }
  if(yyerror_flag && using_list.size()==0)
  {
    if(locations_flag==2)
    {
      fout<<"void yyerror(YYLTYPE *yyloc, void *scanner, const char* msg) {\n"
            "  std::cerr<<yylex_filename(scanner,yyloc->last.file)<<':'<<yyloc->last.line<<':'<<yyloc->last.column<<\": \";\n"
            "  yyerror(msg);\n"
            "}\n";
    }
    else if(locations_flag==1)
      fout<<"void yyerror(void *scanner, const char* msg) {\n"
            "  std::cerr<<yylex_filename(scanner,-1)<<':'<<yylineno<<\": \";\n"
            "  yyerror(msg);\n"
            "}\n";
    else
      fout<<"void yyerror(void *, const char* msg)\n{ yyerror(msg); }\n";
    fout<<"void yyerror(const std::string& msg)\n"
          "{ std::cerr<<msg<<std::endl;\n"
          "  exit(1);\n"
          "}\n";
  }
  if(main_flag)
  {
    fout<<"int yydebug_flag=0;\n"
          "const char* yyinputfile=\"\";\n"
          "int yylex_loop(void *scanner)\n"
          "{ int t;\n"
          "  YYSTYPE yylval;\n";
    if(locations_flag==2)
      fout<<"  YYLTYPE yylloc;\n"
            "  while(t=yylex(&yylval,&yylloc,scanner))\n";
    else  
      fout<<"  while(t=yylex(&yylval,scanner))\n";
    if(lexprint_flag) {
      fout<<"    if(yydebug_flag==1) {\n";
    if(locations_flag==2)
      fout<<"      cout<<yylloc.first.line<<':'<<yylloc.first.column<<' '<<yylloc.last.line<<':'<<yylloc.last.column<<' ';\n";
      fout<<"      lexprint(std::cout,t,yylval); std::cout<<std::endl;\n"
            "    }\n";
    }
    else
      fout<<"    ;\n";
    fout<<"  return 0;\n"
          "}\n"
          "int yyparse_file(const char* name)\n"
          "{ void *scanner=nullptr;\n"
          "  FILE *f=nullptr;\n"
          "  yyinputfile=name;\n"
          "#ifdef YYINIT\n"
          "  YYINIT(name);\n"
          "#endif\n"
          "  if(name[0])\n"
          "  { f=fopen(name,\"r\");\n"
          "    if(!f) yyerror(\"Can't open file \"+std::string(name));\n"
          "    yylex_init(&scanner,f,name);\n"
          "  }\n"
          "  else yylex_init(&scanner);\n";
    if(!grmfile_exist && yyparse_flag)
      fout<<"  int res=yylex_loop(scanner);\n";
    else
      fout<<"  int res=(yydebug_flag==1)?yylex_loop(scanner):yyparse(scanner);\n";
    fout<<"  yylex_destroy(scanner);\n"
          "  return res;\n"
          "}\n"
          "int main(int argc, char **argv)\n"
          "{\n"
          "#ifdef YYARGINIT\n"
          "  YYARGINIT(argc,argv);\n"
          "#endif\n"
          "  for(int i=1; i<argc; ++i)\n"
          "    if(argv[i][0]=='-')\n"
          "    { if(argv[i][1]=='d') yydebug_flag=argv[i][2]-'0';\n"
          "    }\n"
          "    else if(yyparse_file(argv[i])) return 1;\n"
          "  if(!yyinputfile[0]) return yyparse_file(\"\"); \n"
          "}\n";
  }
  if(lexprint_flag && using_list.size()==0)
  {
    fout<<"void lexprint(std::ostream &s, int t,YYSTYPE& a) {\n"
          "  if(t==1) s<<\"undef\";\n"
          "  else if(t<256) astprint(s,char(t));\n"
          "  else switch(t) {\n";
    for(auto s:symbols)
    { if(isterminal(s.first) && s.second.terminalnumber)
      {
        fout<<"  case "<<s.second.terminalnumber<<": s<<\"";
        fout<<encode_string(string(1,s.first[0])+encode_string(decode_string(s.first.substr(1,s.first.size()-2)),0)+
              string(1,s.first[0]),0)<<"\";\n";
        if(!empty_type(s.second.tip))
          fout<<"\ts<<\" : \"; astprint(s,a.f"<<union_fields[s.second.tip]<<"_);\n";
        fout<<"\tbreak;\n";
      }
    }
    fout<<"  }\n}\n";
  }
  if(astprint_flag && domains.size()>0)
  {
    fout<<"namespace ast {\n";
    for(auto &d:domains)
    { 
      fout<<"int astprint(std::ostream& s,"<<d.first<<" v, int i, const char* p) {\n"
            "  int r=0;\n  if(!v) s<<\"nullptr\";\n";
      for(auto &n:d.second.nodes)
      {  
        fout<<"  else if(auto _node=dynamic_cast<"<<n<<"_node*>(v)) {\n";
        auto &ni=nodes[n];
        if(ni.types.size()>1)
        {
          fout<<"    print_indent(s,i);\n"
                "    s<<\""<<n<<"(\";\n";
          for(int j=1;j<ni.types.size();++j)
            fout<<"    r+=astprint(s,_node->f"<<j<<"_,i+1,"<<((j<ni.types.size()-1)?"\",\"":"nullptr")<<");\n";
          fout<<"    if(r) print_indent(s,i);\n"
                 "    s<<\")\";\n"
                 "    ++r;\n";
        }
        else
           fout<<"    s<<\""<<n<<"()\";\n";
        fout<<"  }\n";
      }
      fout<<"  if(p) s<<p;\n"
            "  return r;\n"
            "}\n";
    }
    fout<<"}\n";
  }
}
string linked_symbol;
string type_arg(const string &a, List<Gelem> gl, const string &nd, int nn)
{ string s;
  int i=0;
  linked_symbol.clear();
  if(a.size()==0) return ""s;
  if(a[0]=='\'') return "char"s;
  if(a[0]=='\"') return "std::string"s;
  if(a.size()>1 && a[0]=='$' && isdigit(a[1])) 
  { int na=0;
    i=1;
    while(i<a.size() && isdigit(a[i]))
      na=na*10+(a[i++]-'0');
    if(i!=a.size()) return ""s;
    if(na<1 || na>gl.size())
      yyerror("Reference "s+a+" to unknown element");
    Gelem e=gl[na-1];
    match e {
    rule trmelem(s):
         string idn=normalize_terminal(s);
         if(empty_type(symbols[idn].tip))
            yyerror("Terminal "s+string(s)+" don't have a type"s);
         return symbols[idn].tip;
    rule symelem(s):
         auto &sym=symbols[s];
         if(nn>0)
           sym.node_link.push_back(make_pair(nd,nn));
         else if(s!=nd)
         {
           linked_symbol=s;
           symbols[nd].symbol_link.push_back(make_pair(s,-nn));
           sym.symbol_link.push_back(make_pair(nd,nn));
         }
    }
    return ""s;
  }
  while(i<a.size() && (isdigit(a[i]) || a[i]=='\''))
    s+=a[i++];
  if(s.size()>0)
  { s=a.substr(i,1);
    if(s=="."s || s=="e"s || s=="E"s) return "double"s;
    if(a.substr(i,2)=="ll"s) return "int64_t"s;
    if(s=="l"s) return "long"s;
    return "int"s;
  }
  s.clear();
  i=0;
  while(i<a.size() && (isalnum(a[i]) || a[i]=='_' || a[i]==':'))
    s+=a[i++];
  if(is_builtin_type(s)) return s;
  if(s=="yytext"s || s=="text"s || s=="YYText"s) return "std::string"s;
  if(s=="nullptr"s) return "?"s;
  auto it=consts.find(s);
  if(it!=consts.end()) return it->second.tip;
  return ""s;  
}
void assign_type(string &t, const string &nt, const string &id)
{ if(yydebug_flag==3)
    cout<<id<<": "<<t<<" <- "<<nt<<"\n";
  if(nt==""s) return;
  if(nt=="?"s)
  { if(t==""s)
      t=nt;
    else if(t.back()!='?' && is_builtin_type(t))
      t+='?';
    return;
  }
  if(t=="")
    t=nt;
  else if(t=="?"s)
  { if(is_builtin_type(nt))
      t=nt+"?"s;
    else
      t=nt;
  }
  else if(t!=nt)
  { string t1=t,nt1=nt;
    if(t1.back()=='?') t1.pop_back();
    if(nt1.back()=='?') nt1.pop_back();
    if(t1!=nt1)
      yyerror("Types attributes "s+id+" is different: "s+t+" <- "s+nt);
    if(nt.back()=='?')
      t=nt;
  }
}
static int ref_assigned=0;
void calc_types(List<Code> code, int flg)
{ for(auto c:code)
  match c 
  { rule lexem(t):
      if(t=="$$"s)
        ref_assigned=1;
    rule pcode(cc):
      calc_types(cc,flg);
    rule token(val):
      if(flg)
      {
        string idn=normalize_terminal(val);
        string &tip=symbols[idn].tip;
        if(ref_assigned)
        {
          if(empty_type(tip))
            assign_type(tip,default_tip,idn);
        }
        else
        {
          assign_type(tip,"?"s,idn);
        }
      }
  }
}
void calc_types(List<Lrule> lrules)
{ for(auto r:lrules)
  { match r {
    rule lexrule(st, re, act):
      match act {
        rule lterm(id,t):
          if(id && t)
          { string idn=normalize_terminal(id);
            string &tip=symbols[idn].tip;
            if(empty_type(tip))
              assign_type(tip,default_tip,idn);
            if(is_domain(tip)) 
            {
              match t {
              rule tnode(idt,args):
                if(nodes.find(idt)==nodes.end())
                  nodes[idt]=nodeinfo(args.size()+1);
                auto &n=nodes[idt];
                if(args.size()!=n.types.size()-1)
                  yyerror("Wrong number of node "s+idt+" arguments"s);
                assign_type(n.types[0],tip,idt+"(0)"s);
                domains[tip].nodes.insert(idt);
                int nn=1;
                for(auto a:args)
                { assign_type(n.types[nn],type_arg(a,nullptr,idt,nn),idt+"("s+to_string(nn)+")"s);
                  ++nn;
                }
              }
            }
            else
            { 
              match t {
              rule tnode(idt,args):
                if(is_builtin_type(idt))
                  assign_type(tip,idt,id);
              rule snode(str):
                assign_type(tip,type_arg(str,nullptr,id,0),id);
              }
            }
          }
       rule lcode(cc):
         ref_assigned=0;
         calc_types(cc,1);
      }
    }
  }
}
void calc_types(List<Grule> grules)
{
  set<string> new_syms;
  for(auto r:grules)
  { match r {
    rule grmrule(id, body):
      if(symbols[id].defrule!=nullptr)
        yyerror("Redefined symbol "s+id);
      auto &sym=symbols[id];
      sym.defrule=r;
      if(!empty_type(sym.tip))
      { new_syms.insert(id);
      }                 
      for(auto x:body)
      { match x {
        rule xrule(els, act):
          { match act {
            rule gterm(t):
              match t {
              rule tnode(idt,args): 
                  string tip;
                  if(idt=="cons"s)
                  { if(args.size()==1)
                    { tip=type_arg(args[0],els,id,-1);
                      if(!empty_type(tip))
                        if(!is_list_type(tip))
                          tip=list_of_type(tip);
                    }
                    else {
                      if(args.size()!=2)
                        yyerror("Number of cons' arguments should be 1 or 2"s);
                      string link1,link2,tip1,tip2;
                      tip1=type_arg(args[0],els,id,-1);
                      link1=linked_symbol;
                      tip2=type_arg(args[1],els,id,-1);
                      link2=linked_symbol;
                      if(!empty_type(tip2) && !empty_type(tip1) && !is_list_type(tip1) && !is_list_type(tip2))
                      { 
                        yyerror("Using cons for "s+tip1+" and "s+tip2);
                      }
                      if(is_list_type(tip1) && is_list_type(tip2))
                      { if(type_of_list(tip1)!=type_of_list(tip2))
                          yyerror("Using cons() for "s+tip1+" and "s+tip2);
                        tip=tip1;
                      }
                      else
                      { if(empty_type(tip1) || is_list_type(tip1))
                        { swap(tip1,tip2);
                          swap(link1,link2);
                        }
                        if(!empty_type(tip1))
                        { 
                          tip=list_of_type(tip1);
                          if(!empty_type(tip2))
                          {
                            if(tip!=tip2)
                              yyerror("Using cons() for "s+tip1+" and "s+tip2);
                          }
                          if(link2!=""s)
                            assign_type(symbols[link2].tip,tip,link2);
                        }
                        else if(!empty_type(tip2))
                        { if(!is_list_type(tip2))
                            yyerror("Using cons() for "s+tip1+" and "s+tip2);
                          tip=tip2;
                        }
                      }
                      if(link1!=""s && link2!=""s && link1!=link2)
                      {
                        symbols[link1].symbol_link.push_back(make_pair(link2,-2));
                        symbols[link2].symbol_link.push_back(make_pair(link1,-2));
                      }
                    }
                    assign_type(sym.tip,tip,id);
                    if(!empty_type(tip))
                      new_syms.insert(id);
                  }
                  else if(is_builtin_type(idt))
                  { assign_type(sym.tip,idt,id);
                    new_syms.insert(id);
                  }
                  else
                  { 
                    if(nodes.find(idt)==nodes.end())
                      nodes[idt]=nodeinfo(args.size()+1);
                    auto &n=nodes[idt];
                    if(args.size()!=n.types.size()-1)
                      yyerror("Wrong number of node "s+idt+" arguments"s);
                    int nn=1;
                    for(auto a:args)
                    { assign_type(n.types[nn],type_arg(a,els,idt,nn),idt+"("s+to_string(nn)+")"s);
                      ++nn;
                    }
                    sym.node_link.push_back(make_pair(idt,0));
                    n.symbol_link.push_back(id);
                  }
              rule snode(str):
                  string tip=type_arg(str,els,id,0);
                  assign_type(sym.tip,tip,id);
                  if(!empty_type(tip))
                    new_syms.insert(id);
              }
            rule gcode(cc):
               if(empty_type(sym.tip)) 
               {
                 ref_assigned=0;
                 calc_types(cc,0);
                 if(ref_assigned)
                 { 
                   assign_type(sym.tip,default_tip,id);
                   new_syms.insert(id);
                 }
                 else
                   sym.tip="?"s;
               }
               else
               { ref_assigned=0;
                 calc_types(cc,0);
                 if(!ref_assigned)
                 { assign_type(sym.tip,"?"s,id);
                 }
               }
            rule gempty():
               { assign_type(sym.tip,"?"s,id);
               }
            }
          }
        }
      }
    }
  }
  set<string> old_syms;
  int step=0;
  while(new_syms.size()>0)
  { 
    if(yydebug_flag==3)
    { ++step;
      cout<<"Step "<<step<<":\n";
      for(auto &s:new_syms)
      { auto &sym=symbols[s];
        cout<<s<<": "<<sym.tip<<"\n";
      }
    }
    old_syms=new_syms;
    new_syms.clear();
    for(auto &s:old_syms)
    { auto &sym=symbols[s];
      string tip=sym.tip;
      if(yydebug_flag==3)
        cout<<"@ "<<s<<" "<<tip<<"\n";
      for(auto &x:sym.node_link)
      { 
        assign_type(nodes[x.first].types[x.second],tip,x.first+"("s+to_string(x.second)+")"s);
        if(x.second==0)
        {
          domains[tip].nodes.insert(x.first);
          for(auto &sn:nodes[x.first].symbol_link)
          { if(empty_type(symbols[sn].tip))
              new_syms.insert(sn);
            assign_type(symbols[sn].tip,tip,sn);
          }
        }
      }
      for(auto &x:sym.symbol_link)
      { bool flg=empty_type(symbols[x.first].tip);
        if(x.second==0)
          assign_type(symbols[x.first].tip,tip,x.first);
        else if(x.second==-1)
        { if(is_list_type(tip))
            assign_type(symbols[x.first].tip,tip,x.first);
          else    
            assign_type(symbols[x.first].tip,list_of_type(tip),x.first);
        }
        else if(x.second==-2)
        { if(!is_list_type(tip))
            assign_type(symbols[x.first].tip,list_of_type(tip),x.first);
          else
            flg=0;
        }
        else
          flg=0;
        if(flg) 
          new_syms.insert(x.first);
      }
    }
  }
  string bad_node="";
  if(yydebug_flag==3)
    cout<<"Assigned types:\n";
  for(auto &n:nodes)
  { for(auto &t:n.second.types)
      if(empty_type(t))
      { if(bad_node==""s) bad_node=n.first;
      }
      else
      { if(t.back()=='?') usevalue_flag=1;
        if(t=="std::string?"s) usestring_flag=1;
        if(t.substr(0,5)=="List<"s) uselist_flag=1;
      }
      
    if(yydebug_flag==3)
    {
      cout<<n.first<<"(";
      if(n.second.types.size()>1)
      { cout<<n.second.types[1];
        for(int i=2;i<n.second.types.size();++i)
           cout<<", "<<n.second.types[i];
      }  
      cout<<"): "<<n.second.types[0]<<"\n";
    }
  }
  for(auto &s:symbols)
  {
    if(yydebug_flag==3)
    {
      cout<<s.first<<": "<<s.second.tip<<"\n";
    }
    if(!empty_type(s.second.tip))
    { 
      string t=s.second.tip;

      if(t.back()=='?') usevalue_flag=1;
      if(t.substr(0,11)=="std::string"s) usestring_flag=1;
      if(t.substr(0,5)=="List<"s) uselist_flag=1;

      if(union_fields.find(t)==union_fields.end())
      { int k=union_fields.size()+1;
        union_fields[t]=k;
      }
    }
  }
  if(yydebug_flag==3)
  { cout<<"Union:\n";
    for(auto un:union_fields)
      cout<<un.first<<" "<<un.second<<"\n";
  }
  if(bad_node!=""s)
    yyerror("Type of "s+bad_node+" is undefined"s);
}
void yyinterpret(Program prg)
{ match prg {
    rule prog(decls,lrules,grules,code):
    {
      collect_defsymbols(grules);
      check_undefsymbols(grules);
      collect_states(lrules);

      collect_decls(decls);

      collect_terminals(lrules);
      collect_terminals(grules);
      collect_terminals(code);

      new_rules=nullptr;

      calc_types(lrules);
      setup_default(grules);
      if(opers.size())
      { reorder_rules(grules);
        grules=cons(grules,new_rules);
        new_rules=nullptr;
      }
      split_rules(grules);
      grules=cons(grules,new_rules);
      if(yydebug_flag==4) { astprint(cout,grules); return; }

      calc_types(grules);
      gen_altnames();
      if(yydebug_flag) return;

      
      ofstream fout;
      if(lexdefault_flag==-1)
      {
        if(grules) lexdefault_flag=3;
        else lexdefault_flag=1;
      }
      if(yylex_flag)
      { lexfile_exist=1;
        fout.open(filepath+filename+".lex"s);
        create_lexfile(fout,filename,lrules);
        fout.close();
      }
      if(grules && yyparse_flag)
      { grmfile_exist=1;
        fout.open(filepath+filename+".grm"s);
        create_grmfile(fout,filename,grules);
        fout.close();
      }
      fout.open(filepath+filename+".cpp"s);
      create_cppfile(fout,filename,code);
      fout.close();
      fout.open(filepath+filename+".h"s);
      create_hfile(fout,filename);
      fout.close();
    }
  }
}
